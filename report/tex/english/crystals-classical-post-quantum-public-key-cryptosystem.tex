\documentclass[runningheads]{llncs}

\usepackage[long,nodayofweek,level,12hr]{datetime}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{caption}
\usepackage[utf8]{inputenc}
\usepackage{multirow}
\usepackage{tikz}
\usepackage{amssymb}
\usepackage{physics}
\usepackage{stmaryrd}
\usepackage{cleveref}
\usepackage{algorithm}
\usepackage{algpseudocode}

\floatname{algorithm}{Sub-routine}

\makeatletter
\renewcommand\subsubsection{\@startsection{subsubsection}{3}{\z@}%
                       {-18\p@ \@plus -4\p@ \@minus -4\p@}%
                       {0.5em \@plus 0.22em \@minus 0.1em}%
                       {\normalfont\normalsize\bfseries\boldmath}}
\makeatother

\setcounter{secnumdepth}{3}
\numberwithin{equation}{section}

\title{
    CRYSTALS\\(CRYptographic SuiTe for Algebraic LatticeS):\\ A New (Classical) Post-Quantum\\Public-Key Cryptosystem Standard
}

\subtitle{    
    \vspace{4ex} Advanced Topics in Information Security II / Cryptography and Security Protocols\\ \vspace{2ex} \normalsize Ph.D. (Doctoral Program) in Information Security\\ \vspace{2ex} \normalsize Instituto Superior T\'{e}cnico, University of Lisbon\\(2022/2023 - 2${}^{\mathrm{nd}}$ Semester)
    \vspace{-3ex}
}

\titlerunning{
    CRYSTALS: A (Classical) Post-Quantum Public-Key Cryptosystem
}

\author{
    R\'{u}ben Barreiro\inst{1}\thanks{Student Identification: IST1108107} \and
    Paulo Mateus\inst{1,2}\thanks{Acknowledgments and thanks to Prof. Paulo Mateus, who is the lecturer of\break the course ``Advanced Topics in Information Security II / Cryptography and Security\break Protocols'' at Instituto Superior T\'{e}cnico, University of Lisbon, Portugal.}
}

\authorrunning{R\'{u}ben Barreiro et al.}

\institute{
    Instituto Superior T\'{e}cnico, University of Lisbon, Portugal\\
    \email{\{ruben.andre.letra.barreiro,paulo.mateus\}\\@tecnico.ulisboa.pt} \and
    Instituto de Telecomunica\c{c}\~{o}es, Portugal\\
    \email{paulo.mateus@lx.it.pt}
}

\date{\today}


\begin{document}

    \maketitle
    
    \vspace{2ex}

    \hrule

    \vspace{-1ex}
    \begin{figure}[!h]
        \centering
        \includegraphics[width=0.54\linewidth]{figures/logos/cryptosystem/crystals-cryptosystem.pdf}\\
        \begin{minipage}{.5\textwidth}
            \centering
            \vspace{-6ex}
            \includegraphics[width=0.9\linewidth]{figures/logos/college-and-r&d-labs/university-of-lisbon-horizontal-logo.pdf}
        \end{minipage}%
        \hspace{-12ex}
        \begin{minipage}{.5\textwidth}
            \centering
            \vspace{-6ex}
            \includegraphics[width=0.9\linewidth]{figures/logos/college-and-r&d-labs/instituto-superior-tecnico-horizontal-logo.pdf}
        \end{minipage}\\
        \vspace{-8ex}
        \includegraphics[width=0.4\linewidth]{figures/logos/college-and-r&d-labs/instituto-telecomunicacoes-logo.pdf}
    \end{figure}
    \vspace{-1ex}

    \hrule
    
    \newpage

    \begin{abstract}
        In the last few years, Quantum Computing has been growing exponentially, and several quantum algorithms are threatening most of the cryptography we are using nowadays. In 1994, Peter Shor proposed one of them, known nowadays simply as Shorâ€™s algorithm. This algorithm is capable of factoring large integer numbers into smaller prime numbers and finding discrete logarithms in a polylogarithmic time. These two problems are generally considered hard on a classical computer, and we apply this computational hardness assumption as the basis of several cryptosystems we used since the 1970s. For instance, the security factor\break of popular cryptosystems, such as Rivest-Shamir Adleman (RSA),\break Diffie-Hellman (DH), and Elliptic-Curve Cryptography (ECC), rely on this assumption. However, this hardness assumption does not hold for\break quantum computers due to the expected impact of Shor's algorithm.

        Concerning this imminent threat, the scientific community is putting enormous efforts into selecting new quantum-resistant candidates, arising\break two new leading families of quantum-resistant cryptography, known as (Classical) Post Quantum Cryptography and Quantum Cryptography. For the former, we consider mathematical approaches and problems\break believed to be computationally hard to solve in both classical and\break quantum computers. From this family of candidates, we have a popular set of cryptographic primitives based on mathematical problems related to algebraic lattices, commonly known as Lattice-based Cryptography.
        
        In this paper/report, we discuss Lattice-based Cryptography in detail, its fundamentals, as well as the mathematical and computational\break hardness assumptions involved, presenting a detailed description and analysis of CRYptographic SuiTe for Algebraic LatticeS (CRYSTALS) public-key cryptosystem, namely its variants for asymmetric encryption (CRYSTALS-Kyber) and digital signatures (CRYSTALS-Dilithium),\break already selected as the new (and first-ever) standards for public-key\break cryptography to be adopted at the beginning of the post-quantum era.
    \end{abstract}

    \section{Background}
    \label{sec:background}

    Recently, due to the emergence of Quantum Computing and its expected future impact on Modern Cryptography, from the threats arising from some quantum algorithms such as Grover's, Simon's, Brassard-Hoyer-Tapp (BHT), and Shor's algorithms, new quantum-resistant cryptographic primitives are being studied.
    
    These new alternatives of Modern Cryptography are mainly focused on Key Exchanges and Public-Key Cryptography since the expected impacts of Grover's, Simon's, and BHT algorithms on Symmetric Cryptography and Cryptographic Hash Functions are minor when compared to the impact Shor's algorithm will have on Asymmetric Cryptography and Public-Key Cryptosystems we use.
    
    We support this claim since we expect symmetric encryption and\break cryptographic hash algorithms to have their security strength only reduced by half and by a third, respectively. For instance, symmetric encryption algorithms, such as Advanced Encryption Standard (AES), are currently believed to be quantum-resistant when we use them with key sizes doubled regarding what we consider secure nowadays (i.e., 256 bits are considered quantum-resistant) in\break order to resist to brute-force attacks made by Grover's and Simon's algorithms. Similarly, cryptographic hash algorithms, such as Secure Hash Algorithm (SHA), are currently believed to be quantum-resistant when we use them with output sizes tripled regarding what we consider secure nowadays (i.e., 384 bits or more, are believed to be quantum-resistant) in order to resist to collision and birthday attacks made by BHT algorithm (also known as Quantum Birthday Attack).

    In the opposite direction, we expect the Asymmetric and Public-Key\break Cryptography we currently use nowadays to be easily ``broken'' by Shor's\break algorithm in polylogarithmic time, running in a sufficiently powerful Quantum Computer with a large processing capacity, no matter how large the keys used are nor how we change the security parameters. This claim is valid since Shor's algorithm can solve the factorization of large integer numbers into smaller prime numbers as well as the discrete logarithm problem in a very efficient fashion, while most of the currently used public-key cryptosystems, digital signature schemes, and key exchange protocols in our daily lives, such as RSA, DH,\break ElGamal, Digital Signature Algorithm (DSA), and other primitives based on ECC, have their security relied precisely on the computational hardness from\break these two mathematical problems when we consider only classical contexts.\break However, for quantum contexts, all these mentioned cryptographic primitives will become obsolete, and that is the reason why we need to replace them.

    From this incoming need, two new major families of Modern Cryptography arose, one named (Classical) Post-Quantum Cryptography and the other named Quantum Cryptography, as the more suitable candidates for replacement of the cryptographic primitives we use nowadays, which we will start to refer to as (Classical) Pre-Quantum Cryptography to simplify the presented nomenclature.    
    
    The former is very similar to the cryptographic primitives we currently use in (Classical) Pre-Quantum Cryptography and also uses classical information (in the form of bits). However, (Classical) Post-Quantum Cryptography has its basis in mathematical problems and computational assumptions we believe to be hard to be solved by a classical computer and even by a considerably powerful\break quantum computer. In particular, we have several categories of (Classical)\break Post-Quantum Cryptography differing on what type of mathematical problems they have their computational hardness assumptions based on, such as\break Lattice-based Cryptography, Code-based Cryptography, Hash-based\break Cryptography, Isogeny-based Cryptography, Multivariate Cryptography,\break Non-Commutative (Group-based) Cryptography, and Zero-Knowledge Proofs (ZKPs). Since some cryptographic primitives for symmetric encryption and hash computation, such as AES and SHA, for example, are quantum-resistant when used with sufficiently large sizes for keys and outputs, as mentioned before, we can consider them primitives of (Classical) Post-Quantum Cryptography as well.

    The latter follows a very different approach when compared to the previously mentioned (Classical) Pre-Quantum and Post-Quantum Cryptography. Namely, it uses quantum information (in the form of quantum bits, also known simply as qubits, or quantum modes, also known simply as qumodes) in addition to the usual classical information. Moreover, it does not depend on any mathematical\break problems and computational hardness assumptions since it relies on postulates and fundamentals from Quantum Mechanics, as well as laws of physics. More specifically, it uses well-studied quantum phenomena such as Quantum\break Superposition and Quantum Entanglement, as well as postulates and properties ruled from them, such as Wave Interference, Heisenberg's Uncertainty Principle, Observer's Effect, Measurement Statistics (e.g., Non-Locality), No-Go Theorems\break (e.g., No-Cloning and No-Deleting Theorems), Monogamy of Entanglement,\break Special Relativity, among others. Since these quantum phenomena rule nature and reality themselves, they cannot simply be avoided or modified by an attacker, as well as retire any dependence of cryptographic primitives on future advances in computational power and respective continuous cryptoanalysis, reasons why it offers theoretical unconditional security and can achieve perfect security in the future. In particular, from Quantum Cryptography, we can build several cryptographic primitives, such as Quantum Key Distribution (QKD), Semi-Quantum Key Distribution (SQKD), Quantum Conference Key Agreement (QCKA), Semi-Quantum Conference Key Agreement (SQCKA), Quantum Oblivious Transfer (QOT), Quantum Digital Signature (QDS), Quantum Hashing, Quantum Bit Commitment, among others. However, due to the current state of quantum technology, the development and implementation of these physical apparatuses and systems still have their limitations, and there are gaps between its currently available setups and the ideal ones.


    \newpage
    
    \noindent For a global perspective of the current state of Modern Cryptography regarding both classical and quantum contexts, we have the following summary table:

    \vspace{-2ex}
    \begin{table}[ht!]
        \begin{tabular}{|c|c|cc|c|c|}
        \hline
        \multirow{2}{*}{Type}          & Cryptographic                     & \multicolumn{2}{c|}{Security Strength (in bits)}                 & Is Long-Term                     & Possible        \\ \cline{3-4}
        & Primitive                         & \multicolumn{1}{c|}{Classical}            & Quantum              & Secure?                          & Countermeasures \\ \hline
        \multirow{6}{*}{\rotatebox{90}{\parbox{2.35cm}{\centering Symmetric Cryptography}}}     & \multirow{2}{*}{\textit{AES-128}} & \multicolumn{1}{c|}{\multirow{2}{*}{$128$}} & \multirow{2}{*}{$64$}  & \multirow{2}{*}{No}              & Use larger      \\
        &                                   & \multicolumn{1}{c|}{}                     &                      &                                  & symmetric       \\ \cline{2-5}
        & \multirow{2}{*}{\textit{AES-192}} & \multicolumn{1}{c|}{\multirow{2}{*}{$192$}} & \multirow{2}{*}{$96$}  & \multirow{2}{*}{No}              & key sizes       \\
        &                                   & \multicolumn{1}{c|}{}                     &                      &                                  & (with doubled   \\ \cline{2-5}
        & \multirow{2}{*}{\textit{AES-256}} & \multicolumn{1}{c|}{\multirow{2}{*}{$256$}} & \multirow{2}{*}{$128$} & \multirow{2}{*}{Yes}             & sizes)          \\
        &                                   & \multicolumn{1}{c|}{}                     &                      &                                  &                 \\ \hline
        \multirow{6}{*}{\rotatebox{90}{\parbox{2.3cm}{\centering Cryptographic Hash/Digest Functions}}} & \textit{SHA3-224}                 & \multicolumn{1}{c|}{112}                  & $\approx 74$              & No                               & Use larger      \\ \cline{2-5}
        & \textit{SHA3-256}                 & \multicolumn{1}{c|}{$128$}                  & $\approx 85$               & No                               & output          \\ \cline{2-5}
        & \textit{SHA3-384}                 & \multicolumn{1}{c|}{$192$}                  & $128$                  & Yes                              & digest          \\ \cline{2-5}
        & \textit{SHA3-512}                 & \multicolumn{1}{c|}{$256$}                  & $\approx 170$           & Yes                              & sizes           \\ \cline{2-5}
        & \textit{SHAKE128$(d)$}              & \multicolumn{1}{c|}{$\min(\frac{d}{2}, 128)$}        & $\min(\frac{d}{3}, 128)$        & Yes, if $\frac{d}{3} \geq 128$ & (with tripled   \\ \cline{2-5}
        & \textit{SHAKE256$(d)$}              & \multicolumn{1}{c|}{$\min(\frac{d}{2}, 256)$}        & $\min(\frac{d}{3}, 256)$       & Yes, if $\frac{d}{3} \geq 128$ & sizes)          \\ \hline
        \multirow{11}{*}{\rotatebox{90}{\parbox{2cm}{\centering Asymmetric Cryptography}}}   & \textit{RSA}                      & \multicolumn{1}{c|}{}                     &                      & No                               & No direct       \\ \cline{2-5}
        & \textit{DH}                       & \multicolumn{1}{c|}{}                     &                      & No                               & countermeasures \\ \cline{2-5}
        & \textit{DSA}                      & \multicolumn{1}{c|}{}                     &                      & No                               & and new         \\ \cline{2-5}
        & \textit{Elliptic Curve}           & \multicolumn{1}{c|}{\multirow{3}{*}{}}    & \multirow{3}{*}{}    & \multirow{3}{*}{No}              & solutions are   \\
        & \textit{Diffie-Hellman}           & \multicolumn{1}{c|}{}                     &                      &                                  & needed, such as \\
        & \textit{(ECDH)}                   & \multicolumn{1}{c|}{}                     &                      &                                  & (Classical)     \\ \cline{2-5}
        & \textit{Elliptic Curve}           & \multicolumn{1}{c|}{\multirow{4}{*}{}}    & \multirow{4}{*}{}    & \multirow{4}{*}{No}              & Post-Quantum    \\
        & \textit{Digital Signature}        & \multicolumn{1}{c|}{}                     &                      &                                  & Cryptography    \\
        & \textit{Algorithm}                & \multicolumn{1}{c|}{}                     &                      &                                  & or Quantum      \\
        & \textit{(ECDSA)}                  & \multicolumn{1}{c|}{}                     &                      &                                  & Cryptography    \\ \cline{2-5}
        & \textit{ElGamal}                  & \multicolumn{1}{c|}{}                     &                      & No                               &                 \\ \hline
        \end{tabular}
    \end{table}
    
    Even if this cryptographic threat does not seem to have immediate repercussions since the current quantum computers are still very limited in terms of processing capacity and noise, the whole scenario changes if we consider the Harvest Now - Decrypt Later (HNDL) paradigm, where an attacker can store information protected by these cryptographic primitives, waiting for a sufficiently powerful quantum computer to appear in the future, to then, be able to ``break'' such encryption and stole private information, what can lead to critical leakage of confidential information in military and health services, where that information usually needs to be kept as private for several years.
    
    \newpage

    
    \section{Lattice-based Cryptography}
    \label{sec:lattice-based-cryptography}

    Lattice-based Cryptography is the generic term for cryptographic primitives that use geometric groups, known as lattices, in their construction or security proof. In the current state-of-the-art, we believe these mathematical problems involving lattices are computationally hard to be solved efficiently using either classical or quantum computers. For this reason, they are considered prominent candidates for future asymmetric cryptosystems of (Classical) Post-Quantum Cryptography.

    Unlike more widely used and known public-key schemes such as the RSA (Rivest-Shamir-Adleman), DH (Diffie-Hellman), El Gamal, or other popular classical public-key cryptosystems of ECC (Elliptic-Curve Cryptography) that we currently use daily, which could, theoretically, be defeated using Shor's\break quantum algorithm for factoring on a sufficiently powerful quantum computer, some lattice-based constructions appear to be quantum-resistant. Namely, we consider many lattice-based cryptosystems to be (asymptotically) and provable\break secure, under the assumption that it is not known how to solve efficiently some well-studied lattice problems based on their worst-case computational hardness\break via worst-case-to-average-case reductions. Furthermore, these asymmetric\break cryptosystems have robust security proofs based on worst-case computational hardness, relatively efficient implementations, simplicity, and flexibility, as well as offer possible ways to achieve the well-desired Homomorphic Encryption,\break considered one of the holy grails of cryptography by the scientific community.
    
    \newpage
    
    \subsection{What is a Lattice?}
    \label{subsec:what-is-a-lattice}

    First of all, it is necessary to define what is a lattice geometric group and\break structure. A lattice is a set of points in $m$-dimensional space with a periodic geometry. We give an example illustration of a lattice in the following Fig. \ref{fig:lattice-structure-illustrative-example}: 

    \vspace{-2ex}
    \begin{figure}[!ht]
        \centering
        \captionsetup{justification=centering}
        \includegraphics[width=0.625\textwidth]{figures/sections/section-2/lattice-structure-illustrative-example.pdf}
        \caption{An illustrative example of a lattice geometric group,\\ with a possible choice of 2 bases and 2 linear combinations of them.}
        \label{fig:lattice-structure-illustrative-example}
    \end{figure}
    
    \noindent Formally, given $n$-linearly independent vectors from a basis $\{\Vec{{b}_{1}}$, $\Vec{{b}_{2}}$, $\dots$, $\Vec{{b}_{n}}\}$ of ${\mathbb{R}}^{n}$, a lattice structure $\mathcal{L} \subset {\mathbb{R}^{n}}$ generated by them is a linear combination of the basis vectors $\Vec{b}$ and a given set of integer coefficients $x$, defined as follows:
    
    \begin{equation}
        \begin{split}     
            \mathcal{L}(\Vec{{b}_{1}}, \Vec{{b}_{2}}, \dots, \Vec{{b}_{n}}) & = \left\{ \sum_{i = 1}^{n} {c}_{i} \cdot \Vec{{b}_{i}}: {x}_{i} \in \mathbb{Z},\ \Vec{{b}_{i}} \in {\mathbb{R}}^{n} \right\} = \\
            & = {x}_{1} \cdot \Vec{{b}_{1}} + {x}_{2} \cdot \Vec{{b}_{2}} + \dots + {x}_{n} \cdot \Vec{{b}_{n}} = \\
            & = {x}_{1} \cdot
            \begin{pmatrix} 
                {b}_{(1, 1)} \\ {b}_{(1, 2)} \\ \vdots \\ {b}_{(1, n)}
            \end{pmatrix}
            + {x}_{2} \cdot
            \begin{pmatrix} 
                {b}_{(2, 1)} \\ {b}_{(2, 2)} \\ \vdots \\ {b}_{(2, n)}
            \end{pmatrix}
            + \dots + {x}_{n} \cdot
            \begin{pmatrix}
                {b}_{(n, 1)} \\ {b}_{(1, 2)} \\ \vdots \\ {b}_{(n, n)}
            \end{pmatrix}
        \end{split}
        \label{equ:lattice-structure-definition-1}
    \end{equation}
    \vspace{1ex}

    \newpage
    
    \noindent Indeed, the basis can be represented by the matrix $B = \begin{pmatrix} {b}_{1}, {b}_{2}, \dots, {b}_{n} \end{pmatrix}$, having the basis vectors ${b}_{i}$ as their columns, where $1 \leq i \leq n$. Using the matrix notation,\break a lattice structure generated by a matrix $B \in {\mathbb{R}}^{(n \times n)}$ can also be defined by\break $\mathcal{L}(B) = \{\ B \cdot x: B \in {\mathbb{R}}^{(n \times n)},\ x \in {\mathbb{Z}}^{n}\ \}$, using a matrix-multiplication as follows:

    \begin{equation}
        \begin{split}     
            \mathcal{L}(B) & = \left\{\ B \cdot x: B \in {\mathbb{R}}^{(n \times n)},\ x \in {\mathbb{Z}}^{n}\ \right\} = \\
            & = \begin{pmatrix}
                {b}_{(1, 1)} & {b}_{(2, 1)} & \dots & {b}_{(n, 1)} \\
                {b}_{(1, 2)} & {b}_{(2, 2)} & \dots & {b}_{(n, 2)} \\
                \vdots & \vdots & \ddots & \vdots \\
                {b}_{(1, n)} & {b}_{(2, n)} & \dots & {b}_{(n, n)}
            \end{pmatrix} \cdot
            \begin{pmatrix}
                {x}_{1} \\ {x}_{2} \\ \vdots \\ {x}_{n}
            \end{pmatrix} = \\
            & = \begin{pmatrix}
                {b}_{(1, 1)} \cdot {x}_{1} & + & {b}_{(2, 1)} \cdot {x}_{2} & + & \dots & + & {b}_{(n, 1)} \cdot {x}_{n} \\
                {b}_{(1, 2)} \cdot {x}_{1} & + & {b}_{(2, 2)} \cdot {x}_{2} & + & \dots & + & {b}_{(n, 2)} \cdot {x}_{n} \\
                \vdots & + & \vdots & + & \ddots & + & \vdots \\
                {b}_{(1, n)} \cdot {x}_{1} & + & {b}_{(2, n)} \cdot {x}_{2} & + & \dots & + & {b}_{(n, n)} \cdot {x}_{n}
            \end{pmatrix} = \\
            & = \begin{pmatrix}
                {b}_{(1, 1)} \cdot {x}_{1} \\
                {b}_{(1, 2)} \cdot {x}_{1} \\
                \vdots \\
                {b}_{(1, n)} \cdot {x}_{1}
            \end{pmatrix} + 
            \begin{pmatrix}
                {b}_{(2, 1)} \cdot {x}_{2} \\
                {b}_{(2, 2)} \cdot {x}_{2} \\
                \vdots \\
                {b}_{(2, n)} \cdot {x}_{2}
            \end{pmatrix} + \dots +
            \begin{pmatrix}
                {b}_{(n, 1)} \cdot {x}_{n} \\
                {b}_{(n, 2)} \cdot {x}_{n} \\
                \vdots \\
                {b}_{(n, n)} \cdot {x}_{n}
            \end{pmatrix} = \\
            & = \begin{pmatrix}
                {b}_{(1, 1)} \\
                {b}_{(1, 2)} \\
                \vdots \\
                {b}_{(1, n)}
            \end{pmatrix} \cdot {x}_{1} + 
            \begin{pmatrix}
                {b}_{(2, 1)} \\
                {b}_{(2, 2)} \\
                \vdots \\
                {b}_{(2, n)}
            \end{pmatrix} \cdot {x}_{2}+ \dots +
            \begin{pmatrix}
                {b}_{(n, 1)} \\
                {b}_{(n, 2)} \\
                \vdots \\
                {b}_{(n, n)}
            \end{pmatrix} \cdot {x}_{n} = \\
            & = {x}_{1} \cdot
            \begin{pmatrix} 
                {b}_{(1, 1)} \\ {b}_{(1, 2)} \\ \vdots \\ {b}_{(1, n)}
            \end{pmatrix}
            + {x}_{2} \cdot
            \begin{pmatrix} 
                {b}_{(2, 1)} \\ {b}_{(2, 2)} \\ \vdots \\ {b}_{(2, n)}
            \end{pmatrix}
            + \dots + {x}_{n} \cdot
            \begin{pmatrix}
                {b}_{(n, 1)} \\ {b}_{(1, 2)} \\ \vdots \\ {b}_{(n, n)}
            \end{pmatrix} = \\
            & = \mathcal{L}(\Vec{{b}_{1}}, \Vec{{b}_{2}}, \dots, \Vec{{b}_{n}}) \text{ (\ see \Cref{equ:lattice-structure-definition-1} )\ }
        \end{split}
        \label{equ:lattice-structure-definition-2}
    \end{equation}
    \vspace{1ex}

    \noindent Given a particular ($n \times n)$ unimodular matrix $U$, the bases $B$ and $B \cdot U$ generate the same lattice structure. In fact, we have the equality $\mathcal{L}(B) = \mathcal{L}(B')$ if and only if there is a unimodular matrix $U$ such that $B' = BU$. In particular, any lattice structure admits multiple bases, and this mathematical fact represents the core of many lattice-based cryptographic applications and primitives proposed. 

    The determinant of a lattice structure is given by the absolute value of the determinant of the basis matrix $B$, that is, $\det(\mathcal{L}(B)) = |\det(B)|$. The value of the determinant is independent of the choice of the basis and geometrically\break corresponds to the inverse of the density of the points of the lattice structure in ${\mathbb{R}}^{n}$. The dual of a lattice structure $\mathcal{L} \in {\mathbb{R}}^{n}$ denoted ${\mathcal{L}}^{*}$, is the lattice structure\break given by the set of all column $n$-vectors $\Vec{y} \in {\mathbb{R}}^{n}$ that satisfies $\langle \Vec{x}, \Vec{y} \rangle \in \mathbb{Z}$ for all\break column $n$-vectors $\Vec{x} \in \mathcal{L}$. Additionally, we can see that for any $B \in {\mathbb{R}}^{n}$,\break ${\mathcal{L}(B)}^{*} = \mathcal{L}({({B}^{-1})}^{T})$. Therefore, we also obtain the equality $\det({\mathcal{L}}^{*}) = \frac{1}{\det(\mathcal{L})}$. 
    
    Other lattice structures that are particularly important in Lattice-Based Cryptography are $q$-ary (modular) lattice groups. These $q$-ary lattice groups are lattice structures $\mathcal{L}$ satisfying ${\mathbb{Z}}^{n} \subseteq \mathcal{L} \subseteq {\mathbb{Z}}^{n}$ for some prime integer $q$. In other words, we determine the membership of a vector $x \in \mathcal{L}$ by $x \mod q$. Then, we define such lattice groups in one-to-one correspondence with linear codes in ${\mathbb{Z}}^{n}_{q}$. Most constructions of Lattice-Based Cryptography use $q$-ary (modular) lattice groups as their hard-on-average computational problem. Note that any lattice structure of integer elements $\mathcal{L} \subseteq {\mathbb{Z}}^{n}$ is a $q$-ary lattice group for some prime integer $q$. For example, whenever $q$ is an integer multiple of the determinant $\det(\mathcal{L})$. However, we are more concerned with $q$-ary (modular) lattice groups with a prime integer $q$ much smaller than $\det(\mathcal{L})$ in this specific configuration.

    \noindent Namely, given a matrix $X \in {Z}^{(m \times n)}_{q}$ for some integer numbers $q$, $m$, and $n$, we can mathematically define two $n$-dimensional $q$-ary lattice structures as follows:
    
    \begin{enumerate}
        \item ${\Lambda}_{q}(X) = \left\{ \Vec{y} \in {\mathbb{Z}}^{n}: \Vec{y} = {X}^{T} \cdot \Vec{s} \mod q\text{, for some } \Vec{s}\in {\mathbb{Z}}^{m} \right\}$;
        \item ${\Lambda}_{q}^{\perp}(X) = \left\{ \Vec{y} \in {\mathbb{Z}}^{n}: X \cdot \Vec{y} = \Vec{0} \mod q \right\}$.
    \end{enumerate}

    \noindent For the first case, we generate a specific $q$-ary lattice structure from the rows of matrix $X$. In the second case, a $q$-ary lattice structure contains all vectors being orthogonal modulo $q$ to the rows of matrix $X$. In other words, the $q$-ary lattice structure in the first case corresponds to the linear code generated by the rows of the matrix $X$. The one from the second case corresponds to the linear code whose parity check matrix is $X$. It follows since these lattice structures are dual to each other, up to normalization. Namely, we have the following equalities:
    
    \begin{enumerate}
        \item ${\Lambda}_{q}(X) = q \cdot {{\Lambda}_{q}^{\perp}(X)}^{*}$;
        \item ${\Lambda}_{q}^{\perp}(X) = q \cdot {{\Lambda}_{q}(X)}^{*}$.
    \end{enumerate}

    \noindent There are several ways to use lattice structures to build cryptographic primitives for (Classical) Post-Quantum Cryptography that are not always obvious. One first milestone in this line of research is a paper from Mikl\'{o}s Ajtai in 1996, which defined the SIS (Short Integer Solution) problem, and related its average case complexity to the worst-case hardness of finding short vectors in every integer lattice structure, giving novel cryptographic directions, proposing lattice-based one-way functions and trapdoor functions. Then, in the same year, Mikl\'{o}s Ajtai, jointly with Cynthia Dwork, presented a probabilistic public-key cryptosystem based on the hardness of the SVP (Shortest Vector Problem). The hardness assumption they used in their cryptosystem is that it is secure unless it is possible to solve the worst case of a well-known lattice problem in polynomial time.

    But before discussing this type of (Classical) Post-Quantum Cryptography in more detail, we first need to describe some mathematical problems that are computationally hard to solve, involving lattice structures at their core.
    
    \subsection{Lattice-based Problems}
    \label{subsec:lattice-based-problems}

    The constructions of cryptographic primitives for Lattice-based Cryptography use the presumed computational hardness of mathematical problems related to lattice structures, on which the Shortest Vector Problem (SVP) is the most known one and was the inspiration for other similar lattice-based problems. In this case, we start with a lattice structure represented by an arbitrary basis given as an input, and the main goal is to output the shortest non-zero vector in it.

    \vspace{1ex}
    
    \noindent Before entering the details of these problems, we need to introduce the notion of the shortest non-zero vector in a lattice structure $\mathcal{L}$ for a metric $\mathcal{M}$, given as:

    \begin{equation}
        \lambda(\mathcal{L}) = \min_{\Vec{\hat{v}}\ \in\ \mathcal{L} \setminus \{ \Vec{0} \} } {||\Vec{\hat{v}}||}_{\mathcal{M}}
        \label{equ:shortest-non-zero-vector-in-lattice}
    \end{equation}
    \vspace{1ex}

    \noindent
    
    \noindent Another important constant associated with a lattice structure $\mathcal{L}$ is the covering radius. We define a covering radius as the smallest radius $r$ for a family of closed spheres (or circles) with a center ${c}_{i}$, where $r > 0$, such that any $x \in {R}^{n}$ belong at least to one of those spheres (or circles), covering the entire vector space $\mathcal{V}$. In other words, we can define the covering radius $r$ of a lattice structure $\mathcal{L}$ generated from a basis B as the maximum distance ${|| (\Vec{x} - \mathcal{L}(B) ) ||}_{\mathcal{M}}$, for a given metric $\mathcal{M}$, where the vector $\Vec{x}$ ranges over the linear span of the basis $B$. Thus, we can define the notion of covering radius $r$ of a lattice structure $\mathcal{L}$ as follows:

    \begin{equation}
        r = {\rho}_{M}(\mathcal{L}(B)) = \max_{\Vec{x}\ \in\ {\mathbb{R}}^{n}} {|| (\Vec{x} - \mathcal{L}(B) ) ||}_{\mathcal{M}}
        \label{equ:covering-radius-in-lattice}
    \end{equation}
    \vspace{1ex}

    \noindent Now, we can finally enumerate and briefly describe all the most currently known lattice-based mathematical and computational problems, in their \textit{exact} forms:

    \begin{enumerate}
        \item \textbf{\textit{Shortest Vector Problem}} (\textbf{\textit{SVP}}):
        \vspace{0.6ex}
        
        In the SVP instance, a basis of a vector space $\mathcal{V}$ and a metric $\mathcal{M}$, usually the Euclidean norm ${L}^{2}$, are given for a lattice structure $\mathcal{L}$ of size $n$ as input. Then, the goal is to find the shortest non-zero vector in the space vector $\mathcal{V}$, as measured by $\mathcal{M}$, in the lattice structure $\mathcal{L}$. In other words, the solving\break algorithm should output a non-zero vector $\Vec{v}$, such that ${||\Vec{v}||}_{\mathcal{M}} = \lambda(\mathcal{L})$. This mathematical problem in its \textit{exact} form, i.e., without any approximation\break (considering $\gamma(n) = 1$), is only known to be NP-Hard for randomized\break reductions. By contrast, the corresponding problem, when considering the uniform norm for the metric $\mathcal{M}$, is also known to be an NP-Hard problem.

        \newpage

        \item \textbf{\textit{Closest Vector Problem}} (\textbf{\textit{CVP}}):
        \vspace{0.6ex}

        In the CVP instance, a basis of a vector space $\mathcal{V}$ and a metric $\mathcal{M}$, usually the Euclidean norm ${L}^{2}$, are given for a lattice structure $\mathcal{L}$ of size $n$ as input,\break together with a vector $\Vec{v}$ in the vector space $\mathcal{V}$ but not necessarily in the\break lattice structure $\mathcal{L}$. The goal of the solving algorithm is to find the vector $\Vec{v'}$ in the lattice structure $\mathcal{L}$ closest to the given vector $\Vec{v}$, as measured by the given\break metric $\mathcal{M}$. It is also known that any computational hardness of an SVP\break instance implies the same computational hardness for a CVP instance. On the other hand, CVP instances are widely regarded, both in theory and in \break practice, as considerably harder computational problems than SVP instances.
        \vspace{0.1ex}

        \vspace{-0.5ex}
        \item \textbf{\textit{Shortest Independent Vector Problem}} (\textbf{\textit{SIVP}}):
        \vspace{0.6ex}

        In the SIVP instance, a basis of a vector space $\mathcal{V}$ and a metric $\mathcal{M}$,\break usually the Euclidean norm ${L}^{2}$, are given for a lattice structure $\mathcal{L}$ of size $n$ as input. The goal of the solving algorithm is to find a set of $n$\break linearly independent and short non-zero vectors $B' = \{ \Vec{{b'}_{1}}, \Vec{{b'}_{2}}, ..., \Vec{{b'}_{n}} \}$,\break so that ${\max}_{i} {||\Vec{{b'}_{i}}||}_{\mathcal{M}} \leq {\max}_{B} {||\Vec{{b}_{i}}||}_{\mathcal{M}}$, where $1 \leq i \leq n$ and $B = \{ \Vec{{b}_{1}}, \Vec{{b}_{2}}, ..., \Vec{{b}_{n}} \}$. In other words, in the best scenario, we seek to minimize the length of the longest vector in the original basis $B$ and find a new basis $B'$ that yields the same lattice structure $\mathcal{L}$. As far as we know, SIVP instances are also NP-Hard. However, they should generally be harder than SVP instances.
        \vspace{2ex}

        \item \textbf{\textit{Shortest Basis Problem}} (\textbf{\textit{SBP}}):
        \vspace{0.6ex}
        
        In the SBP instance, a basis of a vector space $\mathcal{V}$ and a metric $\mathcal{M}$, usually the Euclidean norm ${L}^{2}$, are given for a lattice structure $\mathcal{L}$ of size $n$ as input. The goal is to find an equivalent basis such that the length of the longest vector in that basis is as short as possible.
        \vspace{2ex}

        \item \textbf{\textit{Covering Radius Problem}} (\textbf{\textit{CRP}}):
        \vspace{0.6ex}

        In the CRP instance, a basis of a vector space $\mathcal{V}$, and a metric $\mathcal{M}$, usually the Euclidean norm ${L}^{2}$, are given for a lattice structure $\mathcal{L}$ of size $n$ as input. The goal is to find the smallest radius $r'$, defined as a rational number, such each sphere (or circle) of radius $r'$ centered around each point of the lattice structure $\mathcal{L}$ together can cover the entire space of the lattice structure. In other words, the goal of the solving algorithm is to find $r'$ such that $r = {\rho}_{\mathcal{M}}(\mathcal{L}(B)) \leq r$, where $r, r' \in \mathbb{Q}$. Oppositely to the previous problems, we still do not know if CRP instances are in the NP-Hard complexity class.
        
        \textcolor{red}{TODO - ver este problema melhor e com mais calma, confirmar se ja se sabe se este problema e NP-Hard ou nao. Wikipedia esta errado??? }
        
        
    \end{enumerate}

    \newpage

    \noindent However, practical lattice-based public-key cryptosystems usually involve other approximate versions of the previously mentioned problems, which are outside\break the regime known to be NP-Hard. In addition, these NP-Hardness results only describe the worst-case asymptotic complexity of the problem, and we do not know how to apply this computational hardness directly to algebraically\break structured lattices. We can describe these approximate instances as follows:

    \begin{enumerate}
        \item \textbf{\textit{$\gamma$-Approximate Shortest Vector Problem}} (\textbf{\textit{$\gamma$-Approximate SVP}}):
        \vspace{0.6ex}
        
        In the $\gamma$-Approximate SVP instance, we consider the setup of the original SVP instance, but with an additional small approximation factor $\gamma$ that works as a \textit{relaxation} to the original \textit{exact} problem. Namely, we also consider a function defined as $\gamma = \gamma(n) \geq 1$ that depends on the dimension $n$ of the lattice structure $\mathcal{L}$. The goal of the solving algorithm is to find a non-zero lattice vector of a scaled length at most $\gamma \cdot \lambda(L)$, setting a lower bound for its shortest size that is greater than the one from the original \textit{exact} problem.
        \vspace{2ex}
        
        \item \textbf{\textit{$\gamma$-Approximate Closest Vector Problem}} (\textbf{\textit{$\gamma$-Approximate CVP}}):
        \vspace{0.6ex}

        In the $\gamma$-Approximate CVP instance, we consider the setup of the original CVP instance, but with an additional small approximation factor $\gamma$ that works as a \textit{relaxation} to the original \textit{exact} problem. Namely, we also consider a function defined as $\gamma = \gamma(n) \geq 1$ that depends on the dimension $n$ of the lattice structure $\mathcal{L}$. The goal of the solving algorithm is to find the vector $\Vec{v'}$ in the lattice structure $\mathcal{L}$ closest to the given vector $\Vec{v}$ at distance at most $\gamma$, as measured by the given metric $\mathcal{M}$, setting a lower bound for the distance to the closest vector that is greater than the one from the \textit{exact} problem.
        \vspace{2ex}
        
        \item \textbf{\textit{$\gamma$-Approximate Shortest Independent Vector Problem}}\\(\textbf{\textit{$\gamma$-Approximate SIVP}}):
        \vspace{0.6ex}
        
        In the $\gamma$-Approximate SIVP instance, we consider the setup of the original SIVP instance, but with an additional small approximation factor $\gamma$ that works as a \textit{relaxation} to the original \textit{exact} problem. Namely, we also consider a function defined as $\gamma = \gamma(n) \geq 1$ that depends on the dimension $n$ of the lattice structure $\mathcal{L}$. The goal of the solving algorithm is to find a set of $n$ linearly independent and short non-zero vectors $B' = \{ \Vec{{b'}_{1}}, \Vec{{b'}_{2}}, ..., \Vec{{b'}_{n}} \}$, so that ${\max}_{i} {||\Vec{{b'}_{i}}||}_{\mathcal{M}} \leq \gamma \cdot {\max}_{B} {||\Vec{{b}_{i}}||}_{\mathcal{M}}$, where $1 \leq i \leq n$ and $B = \{ \Vec{{b}_{1}}, \Vec{{b}_{2}}, ..., \Vec{{b}_{n}} \}$. In other words, in the best scenario, we seek to minimize the length of the longest vector in the original basis $B$ and find a new basis $B'$, scaled by the given approximation factor $\gamma$, that yields the same lattice structure $\mathcal{L}$.
        \vspace{2ex}
        
        \item \textbf{\textit{$\gamma$-Approximate Shortest Basis Problem}} (\textbf{\textit{$\gamma$-Approximate SBP}}):
        \vspace{0.6ex}

        \textcolor{red}{TODO}
        \vspace{2ex}
        
        
        
    \end{enumerate}
    
    \subsection{Algorithms for Lattice-based Problems}
    \label{subsec:algorithms-for-lattice-based-problems}
    
    \newpage
    
    


        \section{CRYSTALS (CRYptographic SuiTe for Algebraic LatticeS)}
    \label{sec:crystals-cryptographic-suite-for-algebraic-lattices}

    The CRYptographic SuiTe for Algebraic LatticeS (CRYSTALS) is a (classical) post-quantum cryptographic suite encompassing two cryptographic primitives, named Kyber and Dilithium. The former is a secure INDistinguishabile under Chosen Plaintext Attack (IND-CPA) asymmetric encryption algorithm and a\break secure INDistinguishable under adaptive Chosen Ciphertext Attack (IND-CCA2) Key Encapsulation Method (KEM), which we can also use as a Key Exchange protocol. The latter is a secure digital signature scheme and is strongly\break Existential UnForgeability under adaptive Chosen-Message Attack (EUF-CMA).
    
    These cryptographic primitives have their security assumptions based on\break computational hardness from mathematical problems over module lattice groups, which are considered, until the current date, secure against attacks made from both classical and quantum computers. Both Kyber and Dilithium have been submitted to the contest of the Post-Quantum Cryptography Standardization project, being finalists of the 3${}^{\mathrm{rd}}$ round of the standardization contest and also selected as some of the first-ever standard cryptographic primitives for the\break post-quantum era. Each of these cryptographic primitives has three variants offering different levels of security, which we will address in detail in this report.
        
    \subsection{CRYSTALS-Kyber}
    \label{subsec:crystals-kyber}

    CRYSTALS-Kyber is a (classical) post-quantum asymmetric cryptosystem\break designed to be quantum-resistant to future cryptanalytic attacks performed by future powerful quantum computers, ensuring security in the classical contexts\break as well. This cryptographic primitive uses a variant of the already mentioned LWE problem on lattice groups as its primary trapdoor function. Namely, this asymmetric cryptosystem won the first spot in the NIST Post-Quantum\break Cryptography Standardization project and is already selected as a new standard to replace the currently used (classical) pre-quantum asymmetric cryptosystems that are vulnerable to attacks performed by quantum computers in the future.

    \vspace{-3ex}
    \begin{figure}[!ht]
        \centering
        \captionsetup{justification=centering}
        \includegraphics[width=0.6\textwidth]{figures/sections/section-3/crystals-kyber.pdf}
        \caption{Logotype of CRYSTALS-Kyber cryptographic primitive.}
        \label{fig:crystals-kyber-logo}
    \end{figure}

    \vspace{-3ex}
    \noindent The design of the primitive CRYSTALS-Kyber has its roots inspired by the LWE-based asymmetric cryptosystem previously proposed by Oded Regev in 2005. Namely, we can improve the practical efficiency of such cryptosystems by employing the same probability distribution used for the noise to build a secret (i.e., a private key) and using a square matrix rather than a rectangular one as the public key. Another improvement is to use polynomial rings rather than integer numbers, as originally used in the NTRU cryptosystem, to define the RLWE and MLWE mathematical problems. From these two main ideas, we build CRYSTALS-Kyber as having its computational hardness assumption based on the MLWE problem. Since from the CRYSTALS-Kyber cryptosystem, we construct the IND-CCA KEM on top of the CPA asymmetric encryption algorithm, the formal definition of the latter will come in the first place.


    \subsubsection{CRYSTALS-Kyber IND-CPA Asymmetric Encryption\\ Algorithm}
    \label{subsubsec:crystals-kyber-ind-cpa-asymmetric-encryption-algorithm}

    Let $k$, ${d}_{t}$, ${d}_{u}$, and ${d}_{v}$ be positive integer parameters, and recall that $n = 256$.\break Additionally, let $\mathcal{M} = { \{ 0 , 1 \} }^{256}$ denote the messages space, where every message\break $m \in \mathcal{M}$ can be viewed as a polynomial in the algebraic ring $\mathcal{R}$ with binary\break coefficients (i.e., in $\{ 0 , 1 \}$). Now, consider the public-key asymmetric encryption\break algorithm denoted by \texorpdfstring{\texttt{CRYSTALS}\textsubscript{\texttt{Kyber}}\texttt{.Asym\_Enc} = \big(\texttt{Key\_Gen}, \texttt{Enc}, \texttt{Dec}\big)}\/. Here, the ciphertexts are of the form $ ct = (u, v) \in \left( { \{ 0, 1 \} }^{\left( 256 \cdot k \cdot {d}_{u} \right)} \times { \{ 0, 1 \} }^{\left( 256 \cdot {d}_{v} \right)} \right)$. Then, in order to properly define the \texorpdfstring{\texttt{CRYSTALS}\textsubscript{\texttt{Kyber}}}\/ asymmetric encryption\break algorithm \texttt{Asym\_Enc}, the sub-routines \texttt{Key\_Gen}, \texttt{Enc}, and \texttt{Dec} are defined as:

    \vspace{-2.75ex}
    \begin{algorithm}
        \caption{\texorpdfstring{\texttt{CRYSTALS}\textsubscript{\texttt{Kyber}}\texttt{.Asym\_Enc}\texttt{.Key\_Gen}()}\/: Key Generation}
        \label{subrou:crystals-kyber-asymmetric-encryption-key-gen}
        
        \textbf{Input:} $\left( n, q, k, \eta \right)$\\
        \textbf{Output:} $\left( {k}_{pub}, {k}_{priv} \right)$
        
        \begin{algorithmic}[1]
            \Require $n = 256$, $q = 7681$, $k > 0$, $\eta > 0$
            \Ensure $n \in \mathbb{Z},\ q \in \mathbb{Z},\ k \in \mathbb{Z},\ \eta \in \mathbb{Z}$
        
            \vspace{2ex}
            
            \State $\rho, \sigma \gets { \{ 0 , 1 \} }^{n} = { \{ 0 , 1 \} }^{256}$
            \State $A \sim {\mathcal{R}}_{q}^{( k \times k )} = {\mathcal{R}}_{7681}^{( k \times k )}$ := \texttt{Sample}($\rho$)
            \State $(s, e) \sim \left( {\beta}_{\eta}^{k} \times {\beta}_{\eta}^{k} \right)$ := \texttt{Sample}($\sigma$)
            \State $t$ := \texttt{Compress}\textsubscript{$q$}$\left( A \cdot s + e, {d}_{t} \right)$
            
            \vspace{1ex}
            
            \State ${k}_{pub}$ := $(t, \rho)$
            \State ${k}_{priv}$ := $s$
            
            \vspace{1ex}
            
            \State \Return $\left( {k}_{pub}, {k}_{priv} \right)$
        \end{algorithmic}
    \end{algorithm}


    \newpage

    
    \begin{algorithm}
        \caption{\texorpdfstring{\texttt{CRYSTALS}\textsubscript{\texttt{Kyber}}\texttt{.Asym\_Enc}\texttt{.Enc}(${k}_{pub} = (t, \rho)$, $m$)}\/: Asymmetric\\ \phantom{|..................................................................................................}Encryption}
        \label{subrou:crystals-kyber-asymmetric-encryption-enc}
        
        \textbf{Input:} $\left( n, q, k, \eta, {k}_{pub}, m \right)$\\
        \textbf{Output:} $ ct $
        
        \begin{algorithmic}[1]
            \Require $n = 256$, $q = 7681$, $k > 0$, $\eta > 0$
            \Ensure $n \in \mathbb{Z},\ q \in \mathbb{Z},\ k \in \mathbb{Z},\ \eta \in \mathbb{Z},\ m \in \mathcal{M}$
        
            \vspace{2ex}
            
            \State $r \gets { \{ 0 , 1 \} }^{n} = { \{ 0 , 1 \} }^{256}$
            \State $t$ := \texttt{Decompress}\textsubscript{$q$}$(t, {d}_{t})$
            \State $A \sim {\mathcal{R}}_{q}^{( k \times k )} = {\mathcal{R}}_{7681}^{( k \times k )}$ := \texttt{Sample}($\rho$)
            \State $(r, {e}_{1}, {e}_{2}) \sim \left( {\beta}_{\eta}^{k} \times {\beta}_{\eta}^{k} \times {\beta}_{\eta} \right)$ := \texttt{Sample}($r$)

            \vspace{1ex}
            
            \State $u$ := \texttt{Decompress}\textsubscript{$q$}$({A}^{T} \cdot r + {e}_{1}, {d}_{u})$
            \State $u$ := \texttt{Decompress}\textsubscript{$q$}$({t}^{T} \cdot r + {e}_{2} + \left\lceil \frac{q}{2} \right\rfloor \cdot m, {d}_{v})$
            
            \vspace{1ex}

            \State $ct$ := $(u, v)$
            
            \vspace{1ex}
            
            \State \Return $ct$
        \end{algorithmic}
    \end{algorithm}

    \vspace{-6ex}
    \begin{algorithm}
        \caption{\texorpdfstring{\texttt{CRYSTALS}\textsubscript{\texttt{Kyber}}\texttt{.Asym\_Enc}\\ \phantom{................................................}\texttt{.Dec}(${k}_{priv} = s$, $ct = (u, v)$)}\/: Asymmetric\\ \phantom{.............................................................................................}Decryption}
        \label{subrou:crystals-kyber-asymmetric-encryption-dec}
        
        \textbf{Input:} $\left( n, q, k, \eta, {k}_{priv}, ct \right)$\\
        \textbf{Output:} $ pt $
  
        \begin{algorithmic}[1]
            \Require $n = 256$, $q = 7681$, $k > 0$, $\eta > 0$
            \Ensure $n \in \mathbb{Z},\ q \in \mathbb{Z},\ k \in \mathbb{Z},\ \eta \in \mathbb{Z}$
            
            \vspace{2ex}
            
            \State $u$ := \texttt{Decompress}\textsubscript{$q$}$(u, {d}_{u})$
            \State $v$ := \texttt{Decompress}\textsubscript{$q$}$(v, {d}_{v})$
            
            \vspace{1ex}

            \State $pt$ := \texttt{Compress}\textsubscript{$q$}$(v - {s}^{T} \cdot u, 1)$
            
            \vspace{1ex}
            
            \State \Return $pt$
        \end{algorithmic}
    \end{algorithm}
    \vspace{-5ex}

    \paragraph{\textbf{Correctness:}} In order to show the correctness of the \texorpdfstring{\texttt{CRYSTALS}\textsubscript{\texttt{Kyber}}}\/ asymmetric encryption algorithm \texttt{Asym\_Enc}, we need to demonstrate that the same has a negligible decryption error $\delta$, concluding that the algorithm is $(1 - \delta)$-correct.

    \paragraph{\textbf{Theorem 1:}} Let $k$ be a positive integer parameter. Also, let $s$, $e$, $r$, ${e}_{1}$, ${e}_{2}$ be\break random variables that have the same probability distribution as in the previously\break defined sub-routines \texttt{Key\_Gen} and \texttt{Enc} from \texorpdfstring{\texttt{CRYSTALS}\textsubscript{\texttt{Kyber}}}\/ asymmetric\break encryption algorithm \texttt{Asym\_Enc}. Then, let ${c}_{t} \gets {\psi}_{{d}_{t}}^{k}$, ${c}_{u} \gets {\psi}_{{d}_{u}}^{k}$, and ${c}_{v} \gets {\psi}_{{d}_{v}}$, be distributed according to the probability distribution $\psi$ defined as follows:

    \begin{itemize}
        
        \item Let ${\psi}_{d}^{k}$ be the following probability distribution over polynomial ring $\mathcal{R}$:
        
        \begin{enumerate}
            \item Choose uniformly-random $y \gets {\mathcal{R}}^{k}$;
            \item \Return $(\ y - \mathrm{\texttt{Decompress}}\textsubscript{q}( \mathrm{\texttt{Compress}}\textsubscript{q}(y, d), d )\ ) \mod \pm q$.\\ \textcolor{red}{TODO - confirmar mod com superscript +/- na pag 5 do paper ???}
        \end{enumerate}

        \item Denote the decryption error $\delta$ as follows:
        \begin{itemize}
            \item $\delta = \mathrm{Pr}\Big[\ { \big|\big|\ {e}^{T} \cdot r + {e}_{2} + {c}_{v} - {s}^{T} \cdot {e}_{1} + {c}_{t}^{T} \cdot r - {s}^{T} \cdot {c}_{u}\ \big|\big| }_{\infty} \geq \left\lceil \frac{q}{4} \right\rfloor \ \Big]$
        \end{itemize}

        \item Then, we can conclude that \texorpdfstring{\texttt{CRYSTALS}\textsubscript{\texttt{Kyber}}\texttt{.Asym\_Enc}}\/ is $( 1 - \delta )$-correct.
        
    \end{itemize}
    
    \newpage


    \subsubsection{CRYSTALS-Kyber IND-CCA Key Encapsulation Method}
    \label{subsubsec:crystals-kyber-ind-cca-key-encapsulation-method}

    First, let $G: { \{ 0, 1 \} }^{*} \mapsto { \{ 0, 1 \} }^{ ( 2 \times 256 ) }$ and $H: { \{ 0, 1 \} }^{*} \mapsto { \{ 0, 1 \} }^{ 256 }$ be\break cryptographic hash functions. Then, consider the public-key asymmetric KEM denoted by \texorpdfstring{\texttt{CRYSTALS}\textsubscript{\texttt{Kyber}}\texttt{.KEM} = \big(\texttt{Key\_Gen}, \texttt{Encaps}, \texttt{Decaps}\big)}\/, where \texttt{Key\_Gen} is very similar to the sub-routine defined previously in \texorpdfstring{\texttt{CRYSTALS}\textsubscript{\texttt{Kyber}}\texttt{.Asym\_Enc}}, with the difference that ${k}_{priv}$ also contains ${k}_{pub} = (t, \rho)$ and a secret random\break value $z$ with $256$ bits as well. We obtain this asymmetric KEM \texorpdfstring{\texttt{CRYSTALS}\textsubscript{\texttt{Kyber}}\texttt{.KEM}}\/\break algorithm by applying a KEM variant with ``implicit rejection'' of the\break Fujisaki-Okamoto transform to the \texorpdfstring{\texttt{CRYSTALS}\textsubscript{\texttt{Kyber}}\texttt{.Asym\_Enc}}\/ algorithm. The\break sub-routine \texorpdfstring{\texttt{CRYSTALS}\textsubscript{\texttt{Kyber}}\texttt{.KEM}\texttt{.Decaps}}\/ never returns $\bot$ (i.e., \textit{absurdum}).\break Instead, in the case of re-encryption failure, a pseudo-random key $K$ := $H(z, ct)$ is returned, where $z$ is a random secret seed. Then, in order to properly define the \texorpdfstring{\texttt{CRYSTALS}\textsubscript{\texttt{Kyber}}}\/ KEM algorithm \texttt{KEM}, the sub-routines \texttt{Key\_Gen}, \texttt{Encaps}, and \texttt{Decaps} are defined as follows:

    \vspace{-3.4ex}
    \begin{algorithm}
        \caption{\texorpdfstring{\texttt{CRYSTALS}\textsubscript{\texttt{Kyber}}\texttt{.KEM}\texttt{.Encaps}(${k}_{pub} = (t, \rho)$)}\/: Key Encapsulation}
        \label{subrou:crystals-kyber-asymmetric-encryption-encaps}
        
        \textbf{Input:} $\left( n, q, k, \eta, {k}_{priv}, m \right)$\\
        \textbf{Output:} $ encaps $
  
        \begin{algorithmic}[1]
            \Require $n = 256$, $q = 7681$, $k > 0$
            \Ensure $n \in \mathbb{Z},\ q \in \mathbb{Z},\ k \in \mathbb{Z},\ \eta \in \mathbb{Z}$
            
            \vspace{2ex}
            
            \State $m \gets { \{ 0 , 1 \} }^{n} = { \{ 0 , 1 \} }^{256}$
            \State $\big( \hat{K}, r \big)$ := $G( H( {k}_{pub} ) , m )$
            
            \vspace{1ex}

            \State $\left( u, v \right)$ := \texorpdfstring{\texttt{CRYSTALS}\textsubscript{\texttt{Kyber}}\texttt{.Asym\_Enc}\texttt{.Enc}}\/(${k}_{pub}$, $m$, $r$)
            
            \vspace{1ex}

            \State $ct$ := $(u, v)$
            \State $K$ := $H(\hat{K}, H(ct))$
            
            \vspace{1ex}

            \State $encaps$ := $(ct, K)$
            
            \vspace{1ex}
            
            \State \Return $encaps$
        \end{algorithmic}
    \end{algorithm}

    \newpage 
    
    \begin{algorithm}
        \caption{\texorpdfstring{\texttt{CRYSTALS}\textsubscript{\texttt{Kyber}}\texttt{.KEM}\texttt{.Decaps}(${k}_{priv} = (s, z, t, \rho)$, $ct = (u, v)$)}\/:\\ \phantom{.............................................................................................}Key Decapsulation}
        \label{subrou:crystals-kyber-asymmetric-encryption-decaps}
        
        \textbf{Input:} $\left( n, q, k, \eta, {k}_{priv}, m \right)$\\
        \textbf{Output:} $ encapsulation $
  
        \begin{algorithmic}[1]
            \Require $n = 256$, $q = 7681$, $k > 0$
            \Ensure $n \in \mathbb{Z},\ q \in \mathbb{Z},\ k \in \mathbb{Z},\ \eta \in \mathbb{Z}$
            
            \vspace{2ex}
            
            \State $m'$ := \texorpdfstring{\texttt{CRYSTALS}\textsubscript{\texttt{Kyber}}\texttt{.Asym\_Enc}\texttt{.Dec}}\/($s$, $ct$)
            \State $\big( \hat{K'}, r' \big)$ := $G( H( {k}_{pub} ) , m' )$
            
            \vspace{1ex}

            \State $\left( u', v' \right)$ := \texorpdfstring{\texttt{CRYSTALS}\textsubscript{\texttt{Kyber}}\texttt{.Asym\_Enc}\texttt{.Enc}}\/($(t, \rho)$, $m'$; $r'$)
            
            \vspace{1ex}

            \If{$(u', v') = (u, v)$}
                \State $K$ := $H(\hat{K}', H(ct))$
            \Else
                \State $K$ := $H(z, H(ct))$
            \EndIf
            
            \vspace{1ex}
            
            \State \Return $K$
        \end{algorithmic}
    \end{algorithm}

    \newpage
    
    \paragraph{\textbf{Correctness:}} If the \texorpdfstring{\texttt{CRYSTALS}\textsubscript{\texttt{Kyber}}\texttt{.Asym\_Enc}}\/ algorithm is $( 1 - \delta )$-correct and the cryptographic hash function $G$ is a random oracle, then the \texorpdfstring{\texttt{CRYSTALS}\textsubscript{\texttt{Kyber}}\texttt{.KEM}}\/ algorithm is also $( 1 - \delta )$-correct.
    
    \paragraph{\textbf{Security:}} The following concrete security statement proves the security of the \texorpdfstring{\texttt{CRYSTALS}\textsubscript{\texttt{Kyber}}\texttt{.Asym\_Enc}}\/ algorithm when we model the cryptographic hash\break functions $G$ and $H$ as random oracles. Namely, for the concrete security bounds, the KEM variant of the previously mentioned Fujisaki-Okomoto transform is considered, and a non-zero correctness (or decryption) error $\delta$ is also assumed.

    \paragraph{\textbf{Theorem 3:}} For any classical adversary \texttt{A} that makes at most ${q}_{RO}$ many queries to the random oracles $G$ and $H$, and ${q}_{DO}$ queries to the decryption oracle, there is another classical adversary \texttt{B} such that:

    \vspace{-3.4ex}
    $$ {\text{\textbf{Adv}}}_{{\text{\texttt{CRYSTALS}\textsubscript{\texttt{Kyber}}\texttt{.KEM}}}}^{\text{CCA}}\text{(\texttt{A})} \leq 3 \cdot {\text{\textbf{Adv}}}_{{\text{\texttt{CRYSTALS}\textsubscript{\texttt{Kyber}}\texttt{.Asym\_Enc}}}}^{\text{CPA}}\text{(\texttt{B})} + {q}_{RO} \cdot \delta + \frac{ ( 3 \cdot {q}_{RO} ) }{ {2}^{256} } $$

    \noindent As for security in the Quantum Random Oracle Model (QROM), we can use the fact that \texorpdfstring{\texttt{CRYSTALS}\textsubscript{\texttt{Kyber}}\texttt{.Asym\_Enc}}\/ algorithm is ONE-WAY CPA secure and \textit{sparse pseudo-random} to prove that \texorpdfstring{\texttt{CRYSTALS}\textsubscript{\texttt{Kyber}}\texttt{.KEM}}\/ algorithm is INC-CCA secure. Namely, sparse pseudo-randomness is a slightly stronger security notation than the IND-CPA security and essentially states the following properties:

    \begin{enumerate}
        \item A properly generated ciphertext is \textit{pseudo-random} (i.e., it is computationally indistinguishable from a random high-entropy binary string).
        \item A random binary string is, with high probability, not a properly generated ciphertext.
    \end{enumerate}


    \noindent The proof of Theorem 2 shows that the \texorpdfstring{\texttt{CRYSTALS}\textsubscript{\texttt{Kyber}}\texttt{.Asym\_Enc}}\/' algorithm (i.e., the \texorpdfstring{\texttt{CRYSTALS}\textsubscript{\texttt{Kyber}}\texttt{.Asym\_Enc}}\/ algorithm variant without compressing the vector $t$) is tightly pseudo-random under the Module-LWE computational hardness assumption. Concretely, the pseudo-randomness advantage is bounded by:

    $$ {\text{\textbf{Adv}}}_{{\text{\texttt{CRYSTALS}\textsubscript{\texttt{Kyber}}\texttt{.Asym\_Enc}'}}}^{\text{PR}}\text{(\texttt{A})} \leq 2 \cdot {\text{\textbf{Adv}}}_{ ( k + 1, k, \eta ) }^{\text{MLWE}}\text{(\texttt{B})} $$

    \vspace{2ex}
    \noindent Now, we can argue again that the same mathematical bound holds for\break the \texorpdfstring{\texttt{CRYSTALS}\textsubscript{\texttt{Kyber}}\texttt{.Asym\_Enc}}\/ algorithm. Namely, the \texorpdfstring{\texttt{CRYSTALS}\textsubscript{\texttt{Kyber}}\texttt{.Asym\_Enc}}\/\break algorithm has its sparseness property trivially fulfilled since the set of\break properly generated ciphertexts is a sparse subset of the original ciphertext space $\left( { \{ 0, 1 \} }^{ ( 256 \cdot k \cdot {d}_{u}) } \times { \{ 0, 1 \} }^{{d}_{v}} \right)$.\

    \noindent Then, we can also provide the following concrete security statement in the QROM, considering a quantum adversary, for a correctness (decryption) error $\delta$.

    \paragraph{\textbf{Theorem 4:}} For any quantum adversary \texttt{A} that makes at most ${q}_{RO}$ many queries to the quantum random oracles $G$ and $H$, and at most ${q}_{DO}$ (classical) queries to the decryption oracle, there exists a quantum adversary \texttt{B} such that:

    $$ {\text{\textbf{Adv}}}_{{\text{\texttt{CRYSTALS}\textsubscript{\texttt{Kyber}}\texttt{.KEM}}}}^{\text{CCA}}\text{(\texttt{A})} \leq 8 \cdot {q}_{RO}^{2} \cdot \delta + 4 \cdot {q}_{RO} \cdot \sqrt{ {\text{\textbf{Adv}}}_{{\text{\texttt{CRYSTALS}\textsubscript{\texttt{Kyber}}\texttt{.Asym\_Enc}}}}^{\text{PR}}\text{(\texttt{B})} } $$

    \noindent Unfortunately, the above security bound is non-tight, and we can only use it as an asymptotic indication of the CCA security of the \texorpdfstring{\texttt{CRYSTALS}\textsubscript{\texttt{Kyber}}\texttt{.KEM}}\/ algorithm in QROM. However, we can derive a tight security bound in the QROM from a non-standard security assumption, namely that a deterministic version of \texorpdfstring{\texttt{CRYSTALS}\textsubscript{\texttt{Kyber}}\texttt{.Asym\_Enc}}\/ algorithm is sparse pseudo-random in the QROM. The \texorpdfstring{\texttt{CRYSTALS}\textsubscript{\texttt{Kyber}}\texttt{.Asym\_Enc}}\/ algorithm is already deterministic, but the randomness vector $r$ used in the encryption process is derived deterministically from the message m by performing $r := G(m)$. In the Classical Random Oracle Model (CROM), this assumption is tight and implied by the IND-CPA security of \texorpdfstring{\texttt{CRYSTALS}\textsubscript{\texttt{Kyber}}\texttt{.Asym\_Enc}}\/ algorithm, but the security reduction in the QROM is non-tight. For this reason, we need to have the term ${q}_{RO} \cdot \sqrt{ {\text{\textbf{Adv}}}_{{\text{\texttt{CRYSTALS}\textsubscript{\texttt{Kyber}}\texttt{.Asym\_Enc}}}}^{\text{PR}}\text{(\texttt{B})} }$ in Theorem 4).


    \paragraph{\textbf{Hashing ${k}_{pub}$ into $\hat{K}$:}} 

    The transformation used in the \texorpdfstring{\texttt{CRYSTALS}\textsubscript{\texttt{Kyber}}\texttt{.Asym\_Enc}}\/ algorithm is essentially the Fujisakiâ€“Okamoto transform with a small\break adjustment. Most specifically, we need to hash the public key ${k}_{pub}$ by computing\break $\hat{K}$ := $H( {k}_{pub} )$. Namely, this adjustment has two effects. First, this adjustment\break makes the \texorpdfstring{\texttt{CRYSTALS}\textsubscript{\texttt{Kyber}}\texttt{.KEM}}\/ algorithm contributory since the final shared key $K$ does not depend only on the input of one of the two parties involved.\break Second, this adjustment also offers multi-target protection. In particular,\break consider an attacker who searches through many $m$ to find one particular message\break that produces a decryption failure with a considerable probability. Such\break decryption failure of a legitimate ciphertext would leak some information about the secret key. In the pre-quantum context, the negligible decryption error delta guarantees that it is not a practical attack. In the post-quantum context, an attacker can use Grover's algorithm to speed up the search for that message $m$. However, the attacker will have difficulty encoding such message $m$, which may produce a decryption failure with a considerable probability in Grover's quantum\break oracle. In particular, this problem is equivalent to identifying noise vectors that likely have a large inner product with the tuple of vectors $(s, e)$. Eventually,\break the best strategy is to search for a message m that produces noise vectors with a large norm. This attack probably does not offer any better performance than a brute-force attack performed by Grover's algorithm for searching the shared key $K$ with 256 bits. However, applying a cryptographic hash function and transforming ${k}_{pub}$ into $\hat{K}$ ensures that an attacker would not be able to use pre-computed values (i.e., pre-images) of messages $m$ against multiple targets.

    
    
    \subsubsection{CRYSTALS-Kyber Key Exchange Protocol}
    \label{subsubsec:crystals-kyber-key-exchange-protocol}

    Let \texorpdfstring{\texttt{CRYSTALS}\textsubscript{\texttt{Kyber}}\texttt{.KEM} = \big(\texttt{Key\_Gen}, \texttt{Encaps}, \texttt{Decaps}\big)}\/ be the IND-CCA secure KEM algorithm described before. Now, we denote the Key Exchange protocol\break as \texorpdfstring{\texttt{CRYSTALS}\textsubscript{\texttt{Kyber}}\texttt{.KE}}\/, and we obtain it as a direct cryptographic application of the \texorpdfstring{\texttt{CRYSTALS}\textsubscript{\texttt{Kyber}}\texttt{.KEM}}\/ algorithm. In Key Exchange protocols using a KEM algorithm, a cryptographic hash function is commonly applied to all messages each participant sends and receives in order to compose the final secret key. Namely, we compute a cryptographic hash function on the public key ${k}_{pub}$ to obtain the pre-shared key $\hat{K}$, and the ciphertext is then cryptographically hashed into the final secret key $K$. Therefore, the shared secret key $K$ obtained during the Key Exchange protocol already includes these exchanged messages of each participant. We illustrate the steps of the \texorpdfstring{\texttt{CRYSTALS}\textsubscript{\texttt{Kyber}}\texttt{.KE}}\/ algorithm in Fig. \ref{fig:crystals-kyber-key-exchange-protocol-schematic}:

    \vspace{-3ex}
    \begin{figure}[!ht]
        \centering
        \captionsetup{justification=centering}
        \includegraphics[width=\textwidth]{figures/sections/section-3/crystals-kyber-key-exchange-protocol-schematic.pdf}
        \caption{Schematic of the CRYSTALS-Kyber Key Exchange protocol,\\ with the respective Time Events and Messages.}
        \label{fig:crystals-kyber-key-exchange-protocol-schematic}
    \end{figure}

    
    \subsection{CRYSTALS-Dilithium}
    \label{subsec:crystals-dilithium}

    CRYSTALS-Dilithium is a (classical) post-quantum digital signature scheme developed to be closely related and complementary to the CRYSTALS-Kyber asymmetric cryptosystem previously presented, being another component of CRYSTALS. Therefore, this digital signature scheme is also quantum-resistant and intended to be computationally secure against future cryptanalytic attacks performed by future quantum computers with considerable processing power, also ensuring security in the classical contexts. This cryptographic primitive also uses the computational hardness of lattice mathematical problems over module lattices as its trapdoor function and has most of its security notions based on it. For this reason, it is considered strongly secure under a Chosen-Message Attack (CMA). Its security notion also means that an adversary with access to a signing\break oracle cannot produce a signature of a message whose signature he has not yet seen nor produce a different signature of a specific message he already saw signed. Moreover, CRYSTALS-Dilithium is one of the first selected standards for digital signatures in the NIST Post-Quantum Cryptography Standardization project, together with FAst-fourier Lattice-based Compact signatures Over Ntru (FALCON) and Stateless Practical Hash-based Incredibly Nice Cryptographic Signatures${}^{+}$ (SPHINCS${}^{+}$) to replace the currently used (classical) pre-quantum digital signatures that are insecure against to attacks from quantum computers.

    
    \vspace{-3ex}
    \begin{figure}[!ht]
        \centering
        \captionsetup{justification=centering}
        \includegraphics[width=0.6\textwidth]{figures/sections/section-3/crystals-dilithium.pdf}
        \caption{Logotype of CRYSTALS-Dilithium cryptographic primitive.}
        \label{fig:crystals-dilithium-logo}
    \end{figure}


    \noindent The core design of the primitive CRYSTALS-Dilithium is based mainly on a cryptographic technique known as ``Fiat-Shamir with Aborts'', proposed by Vadim Lyubashevsky in 2009. This technique uses rejection sampling in order to make lattice-based Fiat-Shamir digital signature schemes compact and secure.\break It is possible to create digital signature schemes applying this approach, and with small signature sizes, based on the hardness assumption of the mathematical\break problem used in the NTRU lattice-based asymmetric cryptosystem that crucially\break uses random samplings from Gaussian probability distributions. However, since it is hard to implement samplings from the Gaussian probability distribution, the CRYSTALS-Dilithium digital signature scheme uses only the uniform probability\break distribution to obtain those random samplings. This cryptographic primitive\break improved the previous most efficient digital signature scheme that only uses the uniform probability distribution, proposed by Shi Bai and Steven Galbraith in 2013. Namely, CRYSTALS-Dilithium digital signature scheme uses a new\break technique that shrinks the size of the public key by more than half. This digital\break signature scheme has the smallest public key and signature sizes of any known lattice-based digital signature scheme that only uses a uniform probability\break distribution for the random samplings. However, it may have larger sizes for the signature, public key, and private key when we compare it to the other digital signature schemes NIST also selected as new standards in the NIST\break Post-Quantum Cryptography Standardization project. Namely, it has larger public and private keys than SPHINCS${}^{+}$ hash-based digital signature scheme in spite of having shorter signatures. Additionally, the FALCON lattice-based\break digital signature scheme has smaller sizes for the signature, public key, and\break private key than the CRYSTALS-Dilithium digital signature scheme. However, the former uses a Gaussian probability distribution for the random samplings.


    \subsubsection{CRYSTALS-Dilithium Digital Signature}
    \label{subsubsec:crystals-dilithium-digital-signature}

    The CRYSTALS-Dilithium digital signature scheme uses a pseudo-randomness in the signing procedure generated using the well-known cryptographic hash function Secure Hash Algorithm and KECCAK - 256 (SHAKE-256) from the Secure Hash Algorithm - 3 (SHA-3) family as a deterministic function of the message to be signed and a small secret key. Since most of the signing procedure may need to be repeated several times in a computational loop until we build a final signature, a counter is also appended to the input of the SHAKE-256 cryptographic hash function to make its output differ with each signing attempt of the same message $m$. Because each (possibly long) message $m$ may require several iterations to be signed, we compute an initial hash digest of the message $m$ using a collision-resistant hash function. Then, we use the respective hash digest as the input of the cryptographic hash function in the computational loop throughout the signing procedure (see steps 2 and 10 of the sub-routine \ref{subrou:crystals-dilithium-sign}).

    Additionally, one of the primary design improvements offered by the\break CRYSTALS-Dilithium digital signature scheme over the previous ones is the fact that the size of the public key is approximately halved, at the expense of little longer signatures with fewer than a hundred extra bytes. In order to perform this size reduction, the key generation sub-routine outputs ${t}_{1}$ := \texttt{Power2Round}\textsubscript{$q$}$\left( t, {d}_{t} \right)$ as the public key. Additionally, one of the primary design improvements of the CRYSTALS-Dilithium digital signature scheme over the previous ones is the fact that the size of the public key is approximately halved, at the expense of little longer signatures with fewer than a hundred extra bytes. In order to perform this size reduction, the key generation sub-routine outputs ${t}_{1}$ := \texttt{Power2Round}\textsubscript{$q$}$\left( t, {d}_{t} \right)$ as the public key. From this size reduction, the public key requires $\lceil \log{(q)} \rceil - {d}_{t}$ bits per coefficient of the ring polynomial. In the instantiations proposed by the authors, we assume $q \approx {2}^{23}$ and ${d}_{t} = 13$, which means that instead of 23 bits in each coefficient of the public key, there is instead only 10 bits (i.e., $\lceil \log{(q)} \rceil - {d}_{t} = \lceil \log{ ({2}^{23}) } \rceil - 13 = 23 - 13 = 10$), what results in a compression of the size of the public key generated (see the step 6 of the sub-routine \ref{subrou:crystals-dilithium-key-gen}).

    The main complication of not having the entire vector $t$ in the public key is that it is no longer possible to exactly compute ${w}_{1}$ in the signature verification sub-routine. The signature verification will need the high-order bits of $A \cdot z - c \cdot t$ to compute this, but it can only compute $A \cdot z - c \cdot {t}_{1} \cdot {2}^{{d}_{t}} = A \cdot z - c \cdot t + c \cdot {t}_{0}$. Even though the high-order bits of $c \cdot {t}_{0}$ are $0$, its presence in the sum creates ``carry'' bits which may affect the higher bits. The signer of the message thus sends these ``carries'' as a hint to the verifier of the signature. Heuristically, based on the parameter choices proposed by the authors, there should not be more than $\omega$ positions in which a ``carry'' is caused. Therefore, the signer of the message simply sends the positions in which these ``carries'' occur, which allows the verifier to compute the high order bits of $A \cdot z - c \cdot t$ (these are the extra bytes in CRYSTALS-Dilithium compared to other previous similar digital signatures).

    In order to keep the size of the public and private keys small, both the Sign and Verify procedures begin with extracting the matrix $A$ (or more accurately, its NTT domain representation $\hat{A}$) from the pseudo-random seed $\rho$. If storage space is not a factor, then the NTT domain representation matrix $\hat{A}$ can be pre-computed and be part of the public/private key. The signer of the message $m$ can additionally pre-compute the NTT domain representations of $s$, $e$, and ${t}_{0}$ to slightly speed up the signing sub-routine. On the other hand, if the signer of the message m wants to store a private key small as possible, he only needs to store a secret seed $\zeta$ with $32$ bytes, which is used to generate the randomness to create $\rho$, $K$, $s$, and $e$, in the key generation sub-routine. Furthermore, we can also keep the memory for intermediate computations low by only keeping the parts of the NTT domain representation that we are currently working with.

    We can use the CRYSTALS-Dilithium cryptographic primitive to produce deterministic or randomized digital signatures. The former always gives the same digital signature output $\sigma$ for a particular message since we derive the random seed $\rho'$ from the hashed message $\mu$ and a key $K$. The latter does not produce the same digital signature output $\sigma$ for a particular message since we choose the random seed $\rho'$ completely at random (see the step 5 of the sub-routine \ref{subrou:crystals-dilithium-sign}).

    In situations where some side channels that exploit determinism are possible, we may use the randomized variant of this digital signature scheme. Another case where we may want to avoid determinism is when the signer party does not wish to reveal the content of the message which that party is signing. When the digital signature scheme is deterministic, despite not happening timing leakage of the secret key, there is a timing leakage of the hashed message $\mu$. For this case, and since we derive the randomness of this digital signature from the hashed message $\mu$, the number of aborts for a particular message will always be the same.

    \noindent To prove the correctness and security of this digital signature scheme, we need to define a set of lemmas that highlight the properties of its supporting algorithms.

    \paragraph{\textbf{Lemma 1:}} Suppose that $q$ and $\alpha$ are positive integer numbers, where $q > 2 \cdot \alpha$, $q \equiv 1$ (mod $\alpha$), and $\alpha$ is an even number. Let $r$ and $z$ be vectors containing elements in ${R}_{q}$ where ${||z||}_{\infty} \leq \frac{\alpha}{2}$, and let $h$, $h'$ be vectors of bits. Then, the \texttt{HighBits}${}_{q}$, \texttt{MakeHint}${}_{q}$, and \texttt{UseHint}${}_{q}$ algorithms satisfy the following properties: 
    \begin{enumerate}
        \item \texttt{UseHint}${}_{q}$(\texttt{MakeHint}${}_{q}$($z$, $r$, $\alpha$), $r$, $\alpha$) = \texttt{HighBits}${}_{q}$($r + z$, $\alpha$);
        \item Let ${v}_{1}$ = \texttt{UseHint}${}_{q}$($h$, $r$, $\alpha$). Then, we also verify that ${||r - {v}_{1} \cdot \alpha||}_{\infty} \leq \alpha + 1$. Furthermore, if the Hamming Weight of the vector $h$ is equal to $\omega$, then all except at most $w$ coefficients of the result $r - {v}_{1} \cdot \alpha$ will have magnitude at most $\frac{\alpha}{2}$ after centered reduction modulo $q$ using modular multiplications;
        \item For any vectors $h$ and $h'$, if we verify \texttt{UseHint}${}_{q}$($h, r, \alpha$) = \texttt{UseHint}${}_{q}$($h', r, \alpha$), then we can conclude the binary vectors $h$ and $h'$ are equal (i.e., $h$ = $h'$).
    \end{enumerate}

    \paragraph{\textbf{Lemma 2:}} If we verify that ${||s||}_{\infty} \leq \beta$ and ${||\mathrm{\texttt{LowBits}}{}_{q}(r, \alpha)||}_{\infty} < \frac{\alpha}{2} - \beta$, then we can also verify that the equality \texttt{HighBits}${}_{q}$($r, \alpha$) = \texttt{HighBits}${}_{q}$($r + s, \alpha$) holds.

    \paragraph{\textbf{Lemma 3:}} Let $({r}_{1}, {r}_{0})$ = \texttt{Decompose}${}_{q}$($r, \alpha$), $({w}_{1}, {w}_{0})$ = \texttt{Decompose}${}_{q}$($r + s, \alpha$), and ${||s||}_{\infty} \leq \beta$. Then, ${||s + {r}_{0}||}_{\infty} < \frac{\alpha}{2} - \beta \Longleftrightarrow {w}_{1} = {r}_{1} \wedge {||{w}_{0}||}_{\infty} < \frac{\alpha}{2} - \beta$ holds.

    \vspace{5ex}

    \noindent Regarding the details of the correctness property of the CRYSTALS-Dilithium digital signature scheme, we have the following enumerated mathematical proof:

    \begin{itemize}
        \item If ${\big|\big| c \cdot {t}_{0} \big|\big|}_{\infty} < {\gamma}_{2}$, then by Lemma 1 introduced before, we know that \texttt{UseHint}${}_{q}$($h, w - c \cdot e + c \cdot {t}_{0}, 2 \cdot {\gamma}_{2}$) = \texttt{HighBits}${}_{q}$($w - c \cdot e, 2 \cdot {\gamma}_{2}$);
        \item Since we verify that the results $w$ = $A \cdot y$ and $t = A \cdot s + e$ hold, we have that $w - c \cdot e$ = $A \cdot y - c \cdot e$ = $A \cdot (z - c \cdot s) - c \cdot e$ = $A \cdot z - c \cdot t$ holds, and we also verify that the equality $w - c \cdot e + c \cdot {t}_{0}$ = $A \cdot z - c \cdot {t}_{1} \cdot {2}^{{d}_{t}}$ is valid.
        \item Then, the party that verifies if the digital signature is valid, is also able to compute \texttt{UseHint}${}_{q}$($h, A \cdot z - c \cdot {t}_{1} \cdot {2}^{{d}_{t}}, 2 \cdot {\gamma}_{2}$) = \texttt{HighBits}${}_{q}$($w - c \cdot e, 2 \cdot {\gamma}_{2}$);
        \item Furthermore, because we set $\beta$ such we verify that ${||c \cdot e||}_{\infty} \leq \beta$ and the signer party checks that \texttt{LowBits}${}_{q}$$(w - c \cdot e$, $2 \cdot {\gamma}_{2}) < {\gamma}_{2} - \beta$ (see the steps 13 and 14 of the sub-routine \ref{subrou:crystals-dilithium-sign}). Then, Lemma 2 implies the following equalities:
        \begin{equation*} \label{eq1}
            \begin{split}
                \mathrm{\texttt{HighBits}}{}_{q}(w - c \cdot e, 2 \cdot {\gamma}_{2}) & = \mathrm{\texttt{HighBits}}{}_{q}(w - c \cdot e + c \cdot e, 2 \cdot {\gamma}_{2})\\
                 & = \mathrm{\texttt{HighBits}}{}_{q}(w , 2 \cdot {\gamma}_{2}) = {w}_{1}
            \end{split}
        \end{equation*}
        \item Therefore, the vector ${w}_{1}'$ computed by the verifier party to be the input of the hash function is equal to the vector ${w}_{1}$ calculated by the signer party (see the step 4 and 5 of the sub-routine \ref{subrou:crystals-dilithium-verify}, as well as the step 9 of\break the sub-routine \ref{subrou:crystals-dilithium-sign}). And thus, the verification procedure will always accept the digital signature in this case, verifying the correctness property.
    \end{itemize}
        
    \begin{algorithm}
        \caption{\texorpdfstring{\texttt{CRYSTALS}\textsubscript{\texttt{Dilithium}}\texttt{.Key\_Gen}()}\/: Key Generation}
        \label{subrou:crystals-dilithium-key-gen}
        
        \textbf{Input:} $\left( n, q, k, \eta, {k}_{priv}, m \right)$\\
        \textbf{Output:} $ ( {k}_{pub}, {k}_{priv} ) $
    
        \begin{algorithmic}[1]
            \Require $n = 256$, $q = 7681$, $k > 0$
            \Ensure $n \in \mathbb{Z},\ q \in \mathbb{Z},\ k \in \mathbb{Z},\ \eta \in \mathbb{Z}$
            
            \vspace{2ex}
            
            \State $\zeta \gets { \{ 0 , 1 \} }^{n} = { \{ 0 , 1 \} }^{256}$
            \State $(\rho, \rho', K) \sim \left(\ { \{ 0 , 1 \} }^{n} \times { \{ 0 , 1 \} }^{ (2 \cdot n) } \times { \{ 0 , 1 \} }^{n}\ \right) = $
            \Statex \hspace{15ex} $ = \left(\ { \{ 0 , 1 \} }^{256} \times { \{ 0 , 1 \} }^{512} \times { \{ 0 , 1 \} }^{256}\ \right)$ := $H( \zeta )$
            \State $A \sim {\mathcal{R}}_{q}^{( k \times \ell )} = {\mathcal{R}}_{7681}^{( k \times \ell )}$ := \texttt{Sample}($\rho$)
            \State $(s, e) \sim \left( {\upsilon}_{\eta}^{\ell} \times {\upsilon}_{\eta}^{k} \right)$ := \texttt{Sample}($\rho'$)
            \State $t$ := $A \cdot s + e$
            \State $({t}_{1}, {t}_{0})$ := \texttt{Compress}\textsubscript{$q$}$\left( t, {d}_{t} \right)$ = \texttt{Power2Round}\textsubscript{$q$}$\left( t, {d}_{t} \right)$
            \State ${t}_{r} \sim { \{ 0 , 1 \} }^{n} = { \{ 0 , 1 \} }^{256}$ := $H\left( \rho\ ||\ {t}_{1} \right)$
            
            \vspace{1ex}
            
            \State ${k}_{pub}$ := $\left( \rho, {t}_{1} \right)$
            \State ${k}_{priv}$ := $\left( \rho, K, {t}_{r}, s, e, {t}_{0} \right)$
            
            \vspace{1ex}
            
            \State \Return $( {k}_{pub}, {k}_{priv} )$
        \end{algorithmic}
   
    \end{algorithm}

    \begin{algorithm}
        \caption{\texorpdfstring{\texttt{CRYSTALS}\textsubscript{\texttt{Dilithium}}\texttt{.Sign}(${k}_{priv}, M$)}\/: Message Signing}
        \label{subrou:crystals-dilithium-sign}
        
        \textbf{Input:} $\left( n, q, k, \eta, {k}_{priv}, m \right)$\\
        \textbf{Output:} $ ( {k}_{pub}, {k}_{priv} ) $
    
        \begin{algorithmic}[1]
            \Require $n = 256$, $q = 7681$, $k > 0$
            \Ensure $n \in \mathbb{Z},\ q \in \mathbb{Z},\ k \in \mathbb{Z},\ \eta \in \mathbb{Z}$
            
            \vspace{2ex}
            
            \State $A \sim {\mathcal{R}}_{q}^{( k \times \ell )} = {\mathcal{R}}_{7681}^{( k \times \ell )}$ := \texttt{Sample}($\rho$)
            \State $\mu \sim { \{ 0 , 1 \} }^{( 2 \cdot n )} = { \{ 0 , 1 \} }^{512}$ := $H\left( {t}_{r}\ ||\ M \right)$
            \State $\kappa$ := $0$
            \State $(z, h)$ := $\bot$
            \State $\rho' \sim { \{ 0 , 1 \} }^{( 2 \cdot n )} = { \{ 0 , 1 \} }^{512}$ := $H\left( K\ ||\ \mu \right)$ (or $\sigma \gets { \{ 0 , 1 \} }^{( 2 \cdot n )} = { \{ 0 , 1 \} }^{512}$ 
            \Statex \hspace{43.25ex} for randomized signing)
            
            \vspace{1ex}

            \While{$(z, h) = \bot$}
                \State $y \sim { \tilde{\upsilon} }_{ { \gamma }_{1} }^{\ell}$ := \texttt{SampleMask}$( \sigma, \kappa )$
                \State $w$ := $A \cdot y$
                \State ${w}_{1}$ := \texttt{HighBits}\textsubscript{$q$}$( w, 2 \cdot {\gamma}_{2} )$
                \State $\tilde{c} \sim { \{ 0 , 1 \} }^{n} = { \{ 0 , 1 \} }^{256}$ := $H\left( \mu\ ||\ {w}_{1} \right)$
                \State $c \sim {B}_{\tau}$ := \texttt{SampleInBall}$(\tilde{c})$
                \State $z$ := $y + c \cdot s$
                \State ${r}_{0}$ := \texttt{LowBits}\textsubscript{$q$}$( w - c \cdot e, 2 \cdot {\gamma}_{2} )$

                \vspace{1ex}

                \If{ $ \left(\ \left\llbracket\ {\big|\big| z \big|\big|}_{\infty} \geq {\gamma}_{1} - \beta\ \right\rrbracket\ \mathrm{or}\ \left\llbracket\ { \big|\big|{r}_{0} \big|\big| }_{\infty} \geq {\gamma}_{2} - \beta \ \right\rrbracket\ \right) $ }
                    \State $(z, h)$ := $\bot$ 
                \Else
                    \State $h$ := \texttt{MakeHint}\textsubscript{$q$}$( -c \cdot {t}_{0}, w - c \cdot e + c \cdot {t}_{0}, 2 \cdot {\gamma}_{2} )$
                    \If{ $ \left(\ \left\llbracket\ { \big|\big| c \cdot {t}_{0} \big|\big| }_{\infty} \geq {\gamma}_{2} \ \right\rrbracket\ \mathrm{or}\ \left\llbracket\ weight(h) > \omega \ \right\rrbracket\ \right) $ }
                        \State $(z, h)$ := $\bot$ 
                    \EndIf
                \EndIf

                \vspace{1ex}

                \State $\kappa$ := $\kappa + \ell$

                \vspace{1ex}
                
            \EndWhile
            
            \vspace{1ex}
            
            \State \Return $\sigma = \left( \tilde{c}, z, h \right)$
        \end{algorithmic}
   
    \end{algorithm}

    \begin{algorithm}
        \caption{\texorpdfstring{\texttt{CRYSTALS}\textsubscript{\texttt{Dilithium}}\texttt{.Verify}(${k}_{priv}, M, \sigma=(\tilde{c},z,h)$)}\/:\\ \phantom{...................................................................................}Signature Verification}
        \label{subrou:crystals-dilithium-verify}
        
        \textbf{Input:} $\left( n, q, k, \eta, {k}_{priv}, m \right)$\\
        \textbf{Output:} $ ( {k}_{pub}, {k}_{priv} ) $
    
        \begin{algorithmic}[1]
            \Require $n = 256$, $q = 7681$, $k > 0$
            \Ensure $n \in \mathbb{Z},\ q \in \mathbb{Z},\ k \in \mathbb{Z},\ \eta \in \mathbb{Z}$
            
            \vspace{2ex}
            
            \State $A \sim {\mathcal{R}}_{q}^{( k \times \ell )} = {\mathcal{R}}_{7681}^{( k \times \ell )}$ := \texttt{Sample}($\rho$)
            \State $\mu \sim { \{ 0 , 1 \} }^{( 2 \cdot n )} = { \{ 0 , 1 \} }^{512}$ := $H\left( H( \rho, {t}_{1} )\ ||\ M \right)$
            \State $c$ := \texttt{SampleInBall}($\tilde{c}$)
            \State ${w}_{1}'$ := \texttt{UseHint}\textsubscript{$q$}$( h, A \cdot z - c \cdot {t}_{1} \cdot {2}^{{d}_{t}}, 2 \cdot {\gamma}_{2} )$
            \State $is\_valid$ := $\left(\ \big\llbracket\ {\big|\big| z \big|\big|}_{\infty} < {\gamma}_{1} - \beta\ \big\rrbracket\ \mathrm{and}\ \big\llbracket\ \tilde{c} = H(\mu\ ||\ {w}_{1}')\ \big\rrbracket\ \mathrm{and}\ \big\llbracket\ weight(h) \leq \omega\ \big\rrbracket\ \right)$
           
            \vspace{1ex}
            
            \State \Return $is\_valid$
        \end{algorithmic}
   
    \end{algorithm}


\end{document}
