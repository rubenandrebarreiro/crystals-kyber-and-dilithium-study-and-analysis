\documentclass[runningheads]{llncs}

\usepackage[long,nodayofweek,level,12hr]{datetime}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{caption}
\usepackage[utf8]{inputenc}
\usepackage{multirow}
\usepackage{tikz}
\usepackage{amssymb}
\usepackage{physics}
\usepackage{stmaryrd}
\usepackage{cleveref}
\usepackage{algorithm}
\usepackage{algpseudocode}

\floatname{algorithm}{Sub-routine}

\makeatletter
\renewcommand\subsubsection{\@startsection{subsubsection}{3}{\z@}%
                       {-18\p@ \@plus -4\p@ \@minus -4\p@}%
                       {0.5em \@plus 0.22em \@minus 0.1em}%
                       {\normalfont\normalsize\bfseries\boldmath}}
\makeatother

\setcounter{secnumdepth}{3}
\numberwithin{equation}{section}

\title{
    CRYSTALS\\(CRYptographic SuiTe for Algebraic LatticeS):\\ A New (Classical) Post-Quantum\\Public-Key Cryptosystem Standard
}

\subtitle{    
    \vspace{4ex} Advanced Topics in Information Security II / Cryptography and Security Protocols\\ \vspace{2ex} \normalsize Ph.D. (Doctoral Program) in Information Security\\ \vspace{2ex} \normalsize Instituto Superior T\'{e}cnico, University of Lisbon\\(2022/2023 - 2${}^{\mathrm{nd}}$ Semester)
    \vspace{-3ex}
}

\titlerunning{
    CRYSTALS: A (Classical) Post-Quantum Public-Key Cryptosystem
}

\author{
    R\'{u}ben Barreiro\inst{1}\thanks{Student Identification: IST1108107} \and
    Paulo Mateus\inst{1,2}\thanks{Acknowledgments and thanks to Prof. Paulo Mateus, who is the lecturer of\break the course ``Advanced Topics in Information Security II / Cryptography and Security\break Protocols'' at Instituto Superior T\'{e}cnico, University of Lisbon, Portugal.}
}

\authorrunning{R\'{u}ben Barreiro et al.}

\institute{
    Instituto Superior T\'{e}cnico, University of Lisbon, Portugal\\
    \email{\{ruben.andre.letra.barreiro,paulo.mateus\}\\@tecnico.ulisboa.pt} \and
    Instituto de Telecomunica\c{c}\~{o}es, Portugal\\
    \email{paulo.mateus@lx.it.pt}
}

\date{\today}


\begin{document}

    \maketitle
    
    \vspace{2ex}

    \hrule

    \vspace{-1ex}
    \begin{figure}[!h]
        \centering
        \includegraphics[width=0.54\linewidth]{figures/logos/cryptosystem/crystals-cryptosystem.pdf}\\
        \begin{minipage}{.5\textwidth}
            \centering
            \vspace{-6ex}
            \includegraphics[width=0.9\linewidth]{figures/logos/college-and-r&d-labs/university-of-lisbon-horizontal-logo.pdf}
        \end{minipage}%
        \hspace{-12ex}
        \begin{minipage}{.5\textwidth}
            \centering
            \vspace{-6ex}
            \includegraphics[width=0.9\linewidth]{figures/logos/college-and-r&d-labs/instituto-superior-tecnico-horizontal-logo.pdf}
        \end{minipage}\\
        \vspace{-8ex}
        \includegraphics[width=0.4\linewidth]{figures/logos/college-and-r&d-labs/instituto-telecomunicacoes-logo.pdf}
    \end{figure}
    \vspace{-1ex}

    \hrule
    
    \newpage

    \begin{abstract}
        In the last few years, Quantum Computing has been growing exponentially, and several quantum algorithms are threatening most of the cryptography we are using nowadays. In 1994, Peter Shor proposed one of them, known nowadays simply as Shorâ€™s algorithm. This algorithm is capable of factoring large integer numbers into smaller prime numbers and finding discrete logarithms in a polylogarithmic time. These two problems are generally considered hard on a classical computer, and we apply this computational hardness assumption as the basis of several cryptosystems we used since the 1970s. For instance, the security factor\break of popular cryptosystems, such as Rivest-Shamir Adleman (RSA),\break Diffie-Hellman (DH), and Elliptic-Curve Cryptography (ECC), rely on this assumption. However, this hardness assumption does not hold for\break quantum computers due to the expected impact of Shor's algorithm.

        Concerning this imminent threat, the scientific community is putting enormous efforts into selecting new quantum-resistant candidates, arising\break two new leading families of quantum-resistant cryptography, known as (Classical) Post Quantum Cryptography and Quantum Cryptography. For the former, we consider mathematical approaches and problems\break believed to be computationally hard to solve in both classical and\break quantum computers. From this family of candidates, we have a popular set of cryptographic primitives based on mathematical problems related to algebraic lattices, commonly known as Lattice-based Cryptography.
        
        In this paper/report, we discuss Lattice-based Cryptography in detail, its fundamentals, as well as the mathematical and computational\break hardness assumptions involved, presenting a detailed description and analysis of CRYptographic SuiTe for Algebraic LatticeS (CRYSTALS) public-key cryptosystem, namely its variants for asymmetric encryption (CRYSTALS-Kyber) and digital signatures (CRYSTALS-Dilithium),\break already selected as the new (and first-ever) standards for public-key\break cryptography to be adopted at the beginning of the post-quantum era.
    \end{abstract}

    \section{Background}
    \label{sec:background}

    Recently, due to the emergence of Quantum Computing and its expected future impact on Modern Cryptography, from the threats arising from some quantum algorithms such as Grover's, Simon's, Brassard-Hoyer-Tapp (BHT), and Shor's algorithms, new quantum-resistant cryptographic primitives are being studied.
    
    These new alternatives of Modern Cryptography are mainly focused on Key Exchanges and Public-Key Cryptography since the expected impacts of Grover's, Simon's, and BHT algorithms on Symmetric Cryptography and Cryptographic Hash Functions are minor when compared to the impact Shor's algorithm will have on Asymmetric Cryptography and Public-Key Cryptosystems we use.
    
    We support this claim since we expect symmetric encryption and\break cryptographic hash algorithms to have their security strength only reduced by half and by a third, respectively. For instance, symmetric encryption algorithms, such as Advanced Encryption Standard (AES), are currently believed to be quantum-resistant when we use them with key sizes doubled regarding what we consider secure nowadays (i.e., 256 bits are considered quantum-resistant) in\break order to resist to brute-force attacks made by Grover's and Simon's algorithms. Similarly, cryptographic hash algorithms, such as Secure Hash Algorithm (SHA), are currently believed to be quantum-resistant when we use them with output sizes tripled regarding what we consider secure nowadays (i.e., 384 bits or more, are believed to be quantum-resistant) in order to resist to collision and birthday attacks made by BHT algorithm (also known as Quantum Birthday Attack).

    In the opposite direction, we expect the Asymmetric and Public-Key\break Cryptography we currently use nowadays to be easily ``broken'' by Shor's\break algorithm in polylogarithmic time, running in a sufficiently powerful Quantum Computer with a large processing capacity, no matter how large the keys used are nor how we change the security parameters. This claim is valid since Shor's algorithm can solve the factorization of large integer numbers into smaller prime numbers as well as the discrete logarithm problem in a very efficient fashion, while most of the currently used public-key cryptosystems, digital signature schemes, and key exchange protocols in our daily lives, such as RSA, DH,\break ElGamal, Digital Signature Algorithm (DSA), and other primitives based on ECC, have their security relied precisely on the computational hardness from\break these two mathematical problems when we consider only classical contexts.\break However, for quantum contexts, all these mentioned cryptographic primitives will become obsolete, and that is the reason why we need to replace them.

    From this incoming need, two new major families of Modern Cryptography arose, one named (Classical) Post-Quantum Cryptography and the other named Quantum Cryptography, as the more suitable candidates for replacement of the cryptographic primitives we use nowadays, which we will start to refer to as (Classical) Pre-Quantum Cryptography to simplify the presented nomenclature.    
    
    The former is very similar to the cryptographic primitives we currently use in (Classical) Pre-Quantum Cryptography and also uses classical information (in the form of bits). However, (Classical) Post-Quantum Cryptography has its basis in mathematical problems and computational assumptions we believe to be hard to be solved by a classical computer and even by a considerably powerful\break quantum computer. In particular, we have several categories of (Classical)\break Post-Quantum Cryptography differing on what type of mathematical problems they have their computational hardness assumptions based on, such as\break Lattice-based Cryptography, Code-based Cryptography, Hash-based\break Cryptography, Isogeny-based Cryptography, Multivariate Cryptography,\break Non-Commutative (Group-based) Cryptography, and Zero-Knowledge Proofs (ZKPs). Since some cryptographic primitives for symmetric encryption and hash computation, such as AES and SHA, for example, are quantum-resistant when used with sufficiently large sizes for keys and outputs, as mentioned before, we can consider them primitives of (Classical) Post-Quantum Cryptography as well.

    The latter follows a very different approach when compared to the previously mentioned (Classical) Pre-Quantum and Post-Quantum Cryptography. Namely, it uses quantum information (in the form of quantum bits, also known simply as qubits, or quantum modes, also known simply as qumodes) in addition to the usual classical information. Moreover, it does not depend on any mathematical\break problems and computational hardness assumptions since it relies on postulates and fundamentals from Quantum Mechanics, as well as laws of physics. More specifically, it uses well-studied quantum phenomena such as Quantum\break Superposition and Quantum Entanglement, as well as postulates and properties ruled from them, such as Wave Interference, Heisenberg's Uncertainty Principle, Observer's Effect, Measurement Statistics (e.g., Non-Locality), No-Go Theorems\break (e.g., No-Cloning and No-Deleting Theorems), Monogamy of Entanglement,\break Special Relativity, among others. Since these quantum phenomena rule nature and reality themselves, they cannot simply be avoided or modified by an attacker, as well as retire any dependence of cryptographic primitives on future advances in computational power and respective continuous cryptoanalysis, reasons why it offers theoretical unconditional security and can achieve perfect security in the future. In particular, from Quantum Cryptography, we can build several cryptographic primitives, such as Quantum Key Distribution (QKD), Semi-Quantum Key Distribution (SQKD), Quantum Conference Key Agreement (QCKA), Semi-Quantum Conference Key Agreement (SQCKA), Quantum Oblivious Transfer (QOT), Quantum Digital Signature (QDS), Quantum Hashing, Quantum Bit Commitment, among others. However, due to the current state of quantum technology, the development and implementation of these physical apparatuses and systems still have their limitations, and there are gaps between its currently available setups and the ideal ones.


    \newpage
    
    \noindent For a global perspective of the current state of Modern Cryptography regarding both classical and quantum contexts, we have the following summary table:

    \vspace{-2ex}
    \begin{table}[ht!]
        \begin{tabular}{|c|c|cc|c|c|}
        \hline
        \multirow{2}{*}{Type}          & Cryptographic                     & \multicolumn{2}{c|}{Security Strength (in bits)}                 & Is Long-Term                     & Possible        \\ \cline{3-4}
        & Primitive                         & \multicolumn{1}{c|}{Classical}            & Quantum              & Secure?                          & Countermeasures \\ \hline
        \multirow{6}{*}{\rotatebox{90}{\parbox{2.35cm}{\centering Symmetric Cryptography}}}     & \multirow{2}{*}{\textit{AES-128}} & \multicolumn{1}{c|}{\multirow{2}{*}{$128$}} & \multirow{2}{*}{$64$}  & \multirow{2}{*}{No}              & Use larger      \\
        &                                   & \multicolumn{1}{c|}{}                     &                      &                                  & symmetric       \\ \cline{2-5}
        & \multirow{2}{*}{\textit{AES-192}} & \multicolumn{1}{c|}{\multirow{2}{*}{$192$}} & \multirow{2}{*}{$96$}  & \multirow{2}{*}{No}              & key sizes       \\
        &                                   & \multicolumn{1}{c|}{}                     &                      &                                  & (with doubled   \\ \cline{2-5}
        & \multirow{2}{*}{\textit{AES-256}} & \multicolumn{1}{c|}{\multirow{2}{*}{$256$}} & \multirow{2}{*}{$128$} & \multirow{2}{*}{Yes}             & sizes)          \\
        &                                   & \multicolumn{1}{c|}{}                     &                      &                                  &                 \\ \hline
        \multirow{6}{*}{\rotatebox{90}{\parbox{2.3cm}{\centering Cryptographic Hash/Digest Functions}}} & \textit{SHA3-224}                 & \multicolumn{1}{c|}{112}                  & $\approx 74$              & No                               & Use larger      \\ \cline{2-5}
        & \textit{SHA3-256}                 & \multicolumn{1}{c|}{$128$}                  & $\approx 85$               & No                               & output          \\ \cline{2-5}
        & \textit{SHA3-384}                 & \multicolumn{1}{c|}{$192$}                  & $128$                  & Yes                              & digest          \\ \cline{2-5}
        & \textit{SHA3-512}                 & \multicolumn{1}{c|}{$256$}                  & $\approx 170$           & Yes                              & sizes           \\ \cline{2-5}
        & \textit{SHAKE128$(d)$}              & \multicolumn{1}{c|}{$\min(\frac{d}{2}, 128)$}        & $\min(\frac{d}{3}, 128)$        & Yes, if $\frac{d}{3} \geq 128$ & (with tripled   \\ \cline{2-5}
        & \textit{SHAKE256$(d)$}              & \multicolumn{1}{c|}{$\min(\frac{d}{2}, 256)$}        & $\min(\frac{d}{3}, 256)$       & Yes, if $\frac{d}{3} \geq 128$ & sizes)          \\ \hline
        \multirow{11}{*}{\rotatebox{90}{\parbox{2cm}{\centering Asymmetric Cryptography}}}   & \textit{RSA}                      & \multicolumn{1}{c|}{}                     &                      & No                               & No direct       \\ \cline{2-5}
        & \textit{DH}                       & \multicolumn{1}{c|}{}                     &                      & No                               & countermeasures \\ \cline{2-5}
        & \textit{DSA}                      & \multicolumn{1}{c|}{}                     &                      & No                               & and new         \\ \cline{2-5}
        & \textit{Elliptic Curve}           & \multicolumn{1}{c|}{\multirow{3}{*}{}}    & \multirow{3}{*}{}    & \multirow{3}{*}{No}              & solutions are   \\
        & \textit{Diffie-Hellman}           & \multicolumn{1}{c|}{}                     &                      &                                  & needed, such as \\
        & \textit{(ECDH)}                   & \multicolumn{1}{c|}{}                     &                      &                                  & (Classical)     \\ \cline{2-5}
        & \textit{Elliptic Curve}           & \multicolumn{1}{c|}{\multirow{4}{*}{}}    & \multirow{4}{*}{}    & \multirow{4}{*}{No}              & Post-Quantum    \\
        & \textit{Digital Signature}        & \multicolumn{1}{c|}{}                     &                      &                                  & Cryptography    \\
        & \textit{Algorithm}                & \multicolumn{1}{c|}{}                     &                      &                                  & or Quantum      \\
        & \textit{(ECDSA)}                  & \multicolumn{1}{c|}{}                     &                      &                                  & Cryptography    \\ \cline{2-5}
        & \textit{ElGamal}                  & \multicolumn{1}{c|}{}                     &                      & No                               &                 \\ \hline
        \end{tabular}
    \end{table}
    
    Even if this cryptographic threat does not seem to have immediate repercussions since the current quantum computers are still very limited in terms of processing capacity and noise, the whole scenario changes if we consider the Harvest Now - Decrypt Later (HNDL) paradigm, where an attacker can store information protected by these cryptographic primitives, waiting for a sufficiently powerful quantum computer to appear in the future, to then, be able to ``break'' such encryption and stole private information, what can lead to critical leakage of confidential information in military and health services, where that information usually needs to be kept as private for several years.
    
    \newpage

    
    \section{Lattice-based Cryptography}
    \label{sec:lattice-based-cryptography}

    Lattice-based Cryptography is the generic term for cryptographic primitives that use geometric groups, known as lattices, in their construction or security proof. In the current state-of-the-art, we believe these mathematical problems involving lattices are computationally hard to be solved efficiently using either classical or quantum computers. For this reason, they are considered prominent candidates for future asymmetric cryptosystems of (Classical) Post-Quantum Cryptography.

    Unlike more widely used and known public-key schemes such as the RSA (Rivest-Shamir-Adleman), DH (Diffie-Hellman), El Gamal, or other popular classical public-key cryptosystems of ECC (Elliptic-Curve Cryptography) that we currently use daily, which could, theoretically, be defeated using Shor's\break quantum algorithm for factoring on a sufficiently powerful quantum computer, some lattice-based constructions appear to be quantum-resistant. Namely, we consider many lattice-based cryptosystems to be (asymptotically) and provable\break secure, under the assumption that it is not known how to solve efficiently some well-studied lattice problems based on their worst-case computational hardness\break via worst-case-to-average-case reductions. Furthermore, these asymmetric\break cryptosystems have robust security proofs based on worst-case computational hardness, relatively efficient implementations, simplicity, and flexibility, as well as offer possible ways to achieve the well-desired Homomorphic Encryption,\break considered one of the holy grails of cryptography by the scientific community.
    
    \newpage
    
    \subsection{What is a Lattice?}
    \label{subsec:what-is-a-lattice}

    First of all, it is necessary to define what is a lattice geometric group and\break structure. A lattice is a set of points in $m$-dimensional space with a periodic geometry. We give an example illustration of a lattice in the following Fig. \ref{fig:lattice-structure-illustrative-example}: 

    \vspace{-2ex}
    \begin{figure}[!ht]
        \centering
        \captionsetup{justification=centering}
        \includegraphics[width=0.625\textwidth]{figures/sections/section-2/lattice-structure-illustrative-example.pdf}
        \caption{An illustrative example of a lattice geometric group,\\ with a possible choice of 2 bases and 2 linear combinations of them.}
        \label{fig:lattice-structure-illustrative-example}
    \end{figure}
    
    \noindent Formally, given $n$-linearly independent vectors from a basis $\{\Vec{{b}_{1}}$, $\Vec{{b}_{2}}$, $\dots$, $\Vec{{b}_{n}}\}$ of ${\mathbb{R}}^{n}$, a lattice structure $\mathcal{L} \subset {\mathbb{R}^{n}}$ generated by them is a linear combination of the basis vectors $\Vec{b}$ and a given set of integer coefficients $x$, defined as follows:
    
    \begin{equation}
        \begin{split}     
            \mathcal{L}(\Vec{{b}_{1}}, \Vec{{b}_{2}}, \dots, \Vec{{b}_{n}}) & = \left\{ \sum_{i = 1}^{n} {c}_{i} \cdot \Vec{{b}_{i}}: {x}_{i} \in \mathbb{Z},\ \Vec{{b}_{i}} \in {\mathbb{R}}^{n} \right\} = \\
            & = {x}_{1} \cdot \Vec{{b}_{1}} + {x}_{2} \cdot \Vec{{b}_{2}} + \dots + {x}_{n} \cdot \Vec{{b}_{n}} = \\
            & = {x}_{1} \cdot
            \begin{pmatrix} 
                {b}_{(1, 1)} \\ {b}_{(1, 2)} \\ \vdots \\ {b}_{(1, n)}
            \end{pmatrix}
            + {x}_{2} \cdot
            \begin{pmatrix} 
                {b}_{(2, 1)} \\ {b}_{(2, 2)} \\ \vdots \\ {b}_{(2, n)}
            \end{pmatrix}
            + \dots + {x}_{n} \cdot
            \begin{pmatrix}
                {b}_{(n, 1)} \\ {b}_{(1, 2)} \\ \vdots \\ {b}_{(n, n)}
            \end{pmatrix}
        \end{split}
        \label{equ:lattice-structure-definition-1}
    \end{equation}
    \vspace{1ex}

    \newpage
    
    \noindent Indeed, the basis can be represented by the matrix $B = \begin{pmatrix} {b}_{1}, {b}_{2}, \dots, {b}_{n} \end{pmatrix}$, having the basis vectors ${b}_{i}$ as their columns, where $1 \leq i \leq n$. Using the matrix notation,\break a lattice structure generated by a matrix $B \in {\mathbb{R}}^{(n \times n)}$ can also be defined by\break $\mathcal{L}(B) = \{\ B \cdot x: B \in {\mathbb{R}}^{(n \times n)},\ x \in {\mathbb{Z}}^{n}\ \}$, using a matrix-multiplication as follows:

    \begin{equation}
        \begin{split}     
            \mathcal{L}(B) & = \left\{\ B \cdot x: B \in {\mathbb{R}}^{(n \times n)},\ x \in {\mathbb{Z}}^{n}\ \right\} = \\
            & = \begin{pmatrix}
                {b}_{(1, 1)} & {b}_{(2, 1)} & \dots & {b}_{(n, 1)} \\
                {b}_{(1, 2)} & {b}_{(2, 2)} & \dots & {b}_{(n, 2)} \\
                \vdots & \vdots & \ddots & \vdots \\
                {b}_{(1, n)} & {b}_{(2, n)} & \dots & {b}_{(n, n)}
            \end{pmatrix} \cdot
            \begin{pmatrix}
                {x}_{1} \\ {x}_{2} \\ \vdots \\ {x}_{n}
            \end{pmatrix} = \\
            & = \begin{pmatrix}
                {b}_{(1, 1)} \cdot {x}_{1} & + & {b}_{(2, 1)} \cdot {x}_{2} & + & \dots & + & {b}_{(n, 1)} \cdot {x}_{n} \\
                {b}_{(1, 2)} \cdot {x}_{1} & + & {b}_{(2, 2)} \cdot {x}_{2} & + & \dots & + & {b}_{(n, 2)} \cdot {x}_{n} \\
                \vdots & + & \vdots & + & \ddots & + & \vdots \\
                {b}_{(1, n)} \cdot {x}_{1} & + & {b}_{(2, n)} \cdot {x}_{2} & + & \dots & + & {b}_{(n, n)} \cdot {x}_{n}
            \end{pmatrix} = \\
            & = \begin{pmatrix}
                {b}_{(1, 1)} \cdot {x}_{1} \\
                {b}_{(1, 2)} \cdot {x}_{1} \\
                \vdots \\
                {b}_{(1, n)} \cdot {x}_{1}
            \end{pmatrix} + 
            \begin{pmatrix}
                {b}_{(2, 1)} \cdot {x}_{2} \\
                {b}_{(2, 2)} \cdot {x}_{2} \\
                \vdots \\
                {b}_{(2, n)} \cdot {x}_{2}
            \end{pmatrix} + \dots +
            \begin{pmatrix}
                {b}_{(n, 1)} \cdot {x}_{n} \\
                {b}_{(n, 2)} \cdot {x}_{n} \\
                \vdots \\
                {b}_{(n, n)} \cdot {x}_{n}
            \end{pmatrix} = \\
            & = \begin{pmatrix}
                {b}_{(1, 1)} \\
                {b}_{(1, 2)} \\
                \vdots \\
                {b}_{(1, n)}
            \end{pmatrix} \cdot {x}_{1} + 
            \begin{pmatrix}
                {b}_{(2, 1)} \\
                {b}_{(2, 2)} \\
                \vdots \\
                {b}_{(2, n)}
            \end{pmatrix} \cdot {x}_{2}+ \dots +
            \begin{pmatrix}
                {b}_{(n, 1)} \\
                {b}_{(n, 2)} \\
                \vdots \\
                {b}_{(n, n)}
            \end{pmatrix} \cdot {x}_{n} = \\
            & = {x}_{1} \cdot
            \begin{pmatrix} 
                {b}_{(1, 1)} \\ {b}_{(1, 2)} \\ \vdots \\ {b}_{(1, n)}
            \end{pmatrix}
            + {x}_{2} \cdot
            \begin{pmatrix} 
                {b}_{(2, 1)} \\ {b}_{(2, 2)} \\ \vdots \\ {b}_{(2, n)}
            \end{pmatrix}
            + \dots + {x}_{n} \cdot
            \begin{pmatrix}
                {b}_{(n, 1)} \\ {b}_{(1, 2)} \\ \vdots \\ {b}_{(n, n)}
            \end{pmatrix} = \\
            & = \mathcal{L}(\Vec{{b}_{1}}, \Vec{{b}_{2}}, \dots, \Vec{{b}_{n}}) \text{ (\ see \Cref{equ:lattice-structure-definition-1} )\ }
        \end{split}
        \label{equ:lattice-structure-definition-2}
    \end{equation}
    \vspace{1ex}

    \noindent Given a particular ($n \times n)$ unimodular matrix $U$, the bases $B$ and $B \cdot U$ generate the same lattice structure. In fact, we have the equality $\mathcal{L}(B) = \mathcal{L}(B')$ if and only if there is a unimodular matrix $U$ such that $B' = BU$. In particular, any lattice structure admits multiple bases, and this mathematical fact represents the core of many lattice-based cryptographic applications and primitives proposed. 

    The determinant of a lattice structure is given by the absolute value of the determinant of the basis matrix $B$, that is, $\det(\mathcal{L}(B)) = |\det(B)|$. The value of the determinant is independent of the choice of the basis and geometrically\break corresponds to the inverse of the density of the points of the lattice structure in ${\mathbb{R}}^{n}$. The dual of a lattice structure $\mathcal{L} \in {\mathbb{R}}^{n}$ denoted ${\mathcal{L}}^{*}$, is the lattice structure\break given by the set of all column $n$-vectors $\Vec{y} \in {\mathbb{R}}^{n}$ that satisfies $\langle \Vec{x}, \Vec{y} \rangle \in \mathbb{Z}$ for all\break column $n$-vectors $\Vec{x} \in \mathcal{L}$. Additionally, we can see that for any $B \in {\mathbb{R}}^{n}$,\break ${\mathcal{L}(B)}^{*} = \mathcal{L}({({B}^{-1})}^{T})$. Therefore, we also obtain the equality $\det({\mathcal{L}}^{*}) = \frac{1}{\det(\mathcal{L})}$. 
    
    Other lattice structures that are particularly important in Lattice-Based Cryptography are $q$-ary (modular) lattice groups. These $q$-ary lattice groups are lattice structures $\mathcal{L}$ satisfying ${\mathbb{Z}}^{n} \subseteq \mathcal{L} \subseteq {\mathbb{Z}}^{n}$ for some prime integer $q$. In other words, we determine the membership of a vector $x \in \mathcal{L}$ by $x \mod q$. Then, we define such lattice groups in one-to-one correspondence with linear codes in ${\mathbb{Z}}^{n}_{q}$. Most constructions of Lattice-Based Cryptography use $q$-ary (modular) lattice groups as their hard-on-average computational problem. Note that any lattice structure of integer elements $\mathcal{L} \subseteq {\mathbb{Z}}^{n}$ is a $q$-ary lattice group for some prime integer $q$. For example, whenever $q$ is an integer multiple of the determinant $\det(\mathcal{L})$. However, we are more concerned with $q$-ary (modular) lattice groups with a prime integer $q$ much smaller than $\det(\mathcal{L})$ in this specific configuration.

    \noindent Namely, given a matrix $X \in {Z}^{(m \times n)}_{q}$ for some integer numbers $q$, $m$, and $n$, we can mathematically define two $n$-dimensional $q$-ary lattice structures as follows:
    
    \begin{enumerate}
        \item ${\Lambda}_{q}(X) = \left\{ \Vec{y} \in {\mathbb{Z}}^{n}: \Vec{y} = {X}^{T} \cdot \Vec{s} \mod q\text{, for some } \Vec{s}\in {\mathbb{Z}}^{m} \right\}$;
        \item ${\Lambda}_{q}^{\perp}(X) = \left\{ \Vec{y} \in {\mathbb{Z}}^{n}: X \cdot \Vec{y} = \Vec{0} \mod q \right\}$.
    \end{enumerate}

    \noindent For the first case, we generate a specific $q$-ary lattice structure from the rows of matrix $X$. In the second case, a $q$-ary lattice structure contains all vectors being orthogonal modulo $q$ to the rows of matrix $X$. In other words, the $q$-ary lattice structure in the first case corresponds to the linear code generated by the rows of the matrix $X$. The one from the second case corresponds to the linear code whose parity check matrix is $X$. It follows since these lattice structures are dual to each other, up to normalization. Namely, we have the following equalities:
    
    \begin{enumerate}
        \item ${\Lambda}_{q}(X) = q \cdot {{\Lambda}_{q}^{\perp}(X)}^{*}$;
        \item ${\Lambda}_{q}^{\perp}(X) = q \cdot {{\Lambda}_{q}(X)}^{*}$.
    \end{enumerate}

    \noindent There are several ways to use lattice structures to build cryptographic primitives for (Classical) Post-Quantum Cryptography that are not always obvious. One first milestone in this line of research is a paper from Mikl\'{o}s Ajtai in 1996, which defined the SIS (Short Integer Solution) problem, and related its average case complexity to the worst-case hardness of finding short vectors in every integer lattice structure, giving novel cryptographic directions, proposing lattice-based one-way functions and trapdoor functions. Then, in the same year, Mikl\'{o}s Ajtai, jointly with Cynthia Dwork, presented a probabilistic public-key cryptosystem based on the hardness of the SVP (Shortest Vector Problem). The hardness assumption they used in their cryptosystem is that it is secure unless it is possible to solve the worst case of a well-known lattice problem in polynomial time.

    But before discussing this type of (Classical) Post-Quantum Cryptography in more detail, we first need to describe some mathematical problems that are computationally hard to solve, involving lattice structures at their core.
    
    \subsection{Lattice-based Problems}
    \label{subsec:lattice-based-problems}

    The constructions of cryptographic primitives for Lattice-based Cryptography use the presumed computational hardness of mathematical problems related to lattice structures, on which the Shortest Vector Problem (SVP) is the most known one and was the inspiration for other similar lattice-based problems. In this case, we start with a lattice structure represented by an arbitrary basis given as an input, and the main goal is to output the shortest non-zero vector in it.

    \vspace{1ex}
    
    \noindent Before entering the details of these problems, we need to introduce the notion of the shortest non-zero vector in a lattice structure $\mathcal{L}$ for a metric $\mathcal{M}$, given as:

    \begin{equation}
        \lambda(\mathcal{L}) = \min_{\Vec{\hat{v}}\ \in\ \mathcal{L} \setminus \{ \Vec{0} \} } {||\Vec{\hat{v}}||}_{\mathcal{M}}
        \label{equ:shortest-non-zero-vector-in-lattice}
    \end{equation}
    \vspace{1ex}

    \noindent
    
    \noindent Another important constant associated with a lattice structure $\mathcal{L}$ is the covering radius. We define a covering radius as the smallest radius $r$ for a family of closed spheres (or circles) with a center ${c}_{i}$, where $r > 0$, such that any $x \in {R}^{n}$ belong at least to one of those spheres (or circles), covering the entire vector space $\mathcal{V}$. In other words, we can define the covering radius $r$ of a lattice structure $\mathcal{L}$ generated from a basis B as the maximum distance ${|| (\Vec{x} - \mathcal{L}(B) ) ||}_{\mathcal{M}}$, for a given metric $\mathcal{M}$, where the vector $\Vec{x}$ ranges over the linear span of the basis $B$. Thus, we can define the notion of covering radius $r$ of a lattice structure $\mathcal{L}$ as follows:

    \begin{equation}
        r = {\rho}_{M}(\mathcal{L}(B)) = \max_{\Vec{x}\ \in\ {\mathbb{R}}^{n}} {|| (\Vec{x} - \mathcal{L}(B) ) ||}_{\mathcal{M}}
        \label{equ:covering-radius-in-lattice}
    \end{equation}
    \vspace{1ex}

    \noindent Now, we can finally enumerate and briefly describe all the most currently known lattice-based mathematical and computational problems, in their \textit{exact} forms:

    \begin{enumerate}
        \item \textbf{\textit{Shortest Vector Problem}} (\textbf{\textit{SVP}}):
        \vspace{0.6ex}
        
        In the SVP instance, a basis of a vector space $\mathcal{V}$ and a metric $\mathcal{M}$, usually the Euclidean norm ${L}^{2}$, are given for a lattice structure $\mathcal{L}$ of size $n$ as input. Then, the goal is to find the shortest non-zero vector in the space vector $\mathcal{V}$, as measured by $\mathcal{M}$, in the lattice structure $\mathcal{L}$. In other words, the solving\break algorithm should output a non-zero vector $\Vec{v}$, such that ${||\Vec{v}||}_{\mathcal{M}} = \lambda(\mathcal{L})$. This mathematical problem in its \textit{exact} form, i.e., without any approximation\break (considering $\gamma(n) = 1$), is only known to be NP-Hard for randomized\break reductions. By contrast, the corresponding problem, when considering the uniform norm for the metric $\mathcal{M}$, is also known to be an NP-Hard problem.

        \newpage

        \item \textbf{\textit{Closest Vector Problem}} (\textbf{\textit{CVP}}):
        \vspace{0.6ex}

        In the CVP instance, a basis of a vector space $\mathcal{V}$ and a metric $\mathcal{M}$, usually the Euclidean norm ${L}^{2}$, are given for a lattice structure $\mathcal{L}$ of size $n$ as input,\break together with a vector $\Vec{v}$ in the vector space $\mathcal{V}$ but not necessarily in the\break lattice structure $\mathcal{L}$. The goal of the solving algorithm is to find the vector $\Vec{v'}$ in the lattice structure $\mathcal{L}$ closest to the given vector $\Vec{v}$, as measured by the given\break metric $\mathcal{M}$. It is also known that any computational hardness of an SVP\break instance implies the same computational hardness for a CVP instance. On the other hand, CVP instances are widely regarded, both in theory and in \break practice, as considerably harder computational problems than SVP instances.
        \vspace{0.1ex}

        \vspace{-0.5ex}
        \item \textbf{\textit{Shortest Independent Vector Problem}} (\textbf{\textit{SIVP}}):
        \vspace{0.6ex}

        In the SIVP instance, a basis of a vector space $\mathcal{V}$ and a metric $\mathcal{M}$,\break usually the Euclidean norm ${L}^{2}$, are given for a lattice structure $\mathcal{L}$ of size $n$ as input. The goal of the solving algorithm is to find a set of $n$\break linearly independent and short non-zero vectors $B' = \{ \Vec{{b'}_{1}}, \Vec{{b'}_{2}}, ..., \Vec{{b'}_{n}} \}$,\break so that ${\max}_{i} {||\Vec{{b'}_{i}}||}_{\mathcal{M}} \leq {\max}_{B} {||\Vec{{b}_{i}}||}_{\mathcal{M}}$, where $1 \leq i \leq n$ and $B = \{ \Vec{{b}_{1}}, \Vec{{b}_{2}}, ..., \Vec{{b}_{n}} \}$. In other words, in the best scenario, we seek to minimize the length of the longest vector in the original basis $B$ and find a new basis $B'$ that yields the same lattice structure $\mathcal{L}$. As far as we know, SIVP instances are also NP-Hard. However, they should generally be harder than SVP instances.
        \vspace{2ex}

        \item \textbf{\textit{Shortest Basis Problem}} (\textbf{\textit{SBP}}):
        \vspace{0.6ex}
        
        In the SBP instance, a basis of a vector space $\mathcal{V}$ and a metric $\mathcal{M}$, usually the Euclidean norm ${L}^{2}$, are given for a lattice structure $\mathcal{L}$ of size $n$ as input. The goal is to find an equivalent basis such that the length of the longest vector in that basis is as short as possible.
        \vspace{2ex}

        \item \textbf{\textit{Covering Radius Problem}} (\textbf{\textit{CRP}}):
        \vspace{0.6ex}

        In the CRP instance, a basis of a vector space $\mathcal{V}$, and a metric $\mathcal{M}$, usually the Euclidean norm ${L}^{2}$, are given for a lattice structure $\mathcal{L}$ of size $n$ as input. The goal is to find the smallest radius $r'$, defined as a rational number, such each sphere (or circle) of radius $r'$ centered around each point of the lattice structure $\mathcal{L}$ together can cover the entire space of the lattice structure. In other words, the goal of the solving algorithm is to find $r'$ such that $r = {\rho}_{\mathcal{M}}(\mathcal{L}(B)) \leq r$, where $r, r' \in \mathbb{Q}$. Oppositely to the previous problems, we still do not know if CRP instances are in the NP-Hard complexity class.
        
        \textcolor{red}{TODO - ver este problema melhor e com mais calma, confirmar se ja se sabe se este problema e NP-Hard ou nao. Wikipedia esta errado??? }
        
        
    \end{enumerate}

    \newpage

    \noindent However, practical lattice-based public-key cryptosystems usually involve other approximate versions of the previously mentioned problems, which are outside\break the regime known to be NP-Hard. In addition, these NP-Hardness results only describe the worst-case asymptotic complexity of the problem, and we do not know how to apply this computational hardness directly to algebraically\break structured lattices. We can describe these approximate instances as follows:

    \begin{enumerate}
        \item \textbf{\textit{$\gamma$-Approximate Shortest Vector Problem}} (\textbf{\textit{$\gamma$-Approximate SVP}}):
        \vspace{0.6ex}
        
        In the $\gamma$-Approximate SVP instance, we consider the setup of the original SVP instance, but with an additional small approximation factor $\gamma$ that works as a \textit{relaxation} to the original \textit{exact} problem. Namely, we also consider a function defined as $\gamma = \gamma(n) \geq 1$ that depends on the dimension $n$ of the lattice structure $\mathcal{L}$. The goal of the solving algorithm is to find a non-zero lattice vector of a scaled length at most $\gamma \cdot \lambda(L)$, setting a lower bound for its shortest size that is greater than the one from the original \textit{exact} problem.
        \vspace{2ex}
        
        \item \textbf{\textit{$\gamma$-Approximate Closest Vector Problem}} (\textbf{\textit{$\gamma$-Approximate CVP}}):
        \vspace{0.6ex}

        In the $\gamma$-Approximate CVP instance, we consider the setup of the original CVP instance, but with an additional small approximation factor $\gamma$ that works as a \textit{relaxation} to the original \textit{exact} problem. Namely, we also consider a function defined as $\gamma = \gamma(n) \geq 1$ that depends on the dimension $n$ of the lattice structure $\mathcal{L}$. The goal of the solving algorithm is to find the vector $\Vec{v'}$ in the lattice structure $\mathcal{L}$ closest to the given vector $\Vec{v}$ at distance at most $\gamma$, as measured by the given metric $\mathcal{M}$, setting a lower bound for the distance to the closest vector that is greater than the one from the \textit{exact} problem.
        \vspace{2ex}
        
        \item \textbf{\textit{$\gamma$-Approximate Shortest Independent Vector Problem}}\\(\textbf{\textit{$\gamma$-Approximate SIVP}}):
        \vspace{0.6ex}
        
        In the $\gamma$-Approximate SIVP instance, we consider the setup of the original SIVP instance, but with an additional small approximation factor $\gamma$ that works as a \textit{relaxation} to the original \textit{exact} problem. Namely, we also consider a function defined as $\gamma = \gamma(n) \geq 1$ that depends on the dimension $n$ of the lattice structure $\mathcal{L}$. The goal of the solving algorithm is to find a set of $n$ linearly independent and short non-zero vectors $B' = \{ \Vec{{b'}_{1}}, \Vec{{b'}_{2}}, ..., \Vec{{b'}_{n}} \}$, so that ${\max}_{i} {||\Vec{{b'}_{i}}||}_{\mathcal{M}} \leq \gamma \cdot {\max}_{B} {||\Vec{{b}_{i}}||}_{\mathcal{M}}$, where $1 \leq i \leq n$ and $B = \{ \Vec{{b}_{1}}, \Vec{{b}_{2}}, ..., \Vec{{b}_{n}} \}$. In other words, in the best scenario, we seek to minimize the length of the longest vector in the original basis $B$ and find a new basis $B'$, scaled by the given approximation factor $\gamma$, that yields the same lattice structure $\mathcal{L}$.
        \vspace{2ex}
        
        \item \textbf{\textit{$\gamma$-Approximate Shortest Basis Problem}} (\textbf{\textit{$\gamma$-Approximate SBP}}):
        \vspace{0.6ex}

        \textcolor{red}{TODO}
        \vspace{2ex}
        
        
        
    \end{enumerate}
    
    \subsection{Algorithms for Lattice-based Problems}
    \label{subsec:algorithms-for-lattice-based-problems}
    
    \newpage
    
    
\end{document}
